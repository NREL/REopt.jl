<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Adding a Technology · REopt.jl Documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">REopt.jl Documentation</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">REopt</span><ul><li><a class="tocitem" href="../../reopt/examples/">Examples</a></li><li><a class="tocitem" href="../../reopt/inputs/">REopt Inputs</a></li><li><a class="tocitem" href="../../reopt/outputs/">Outputs</a></li><li><a class="tocitem" href="../../reopt/methods/">Methods</a></li></ul></li><li><span class="tocitem">Model Predictive Control</span><ul><li><a class="tocitem" href="../../mpc/examples/">MPC Examples</a></li><li><a class="tocitem" href="../../mpc/inputs/">MPC Inputs</a></li><li><a class="tocitem" href="../../mpc/outputs/">MPC Outputs</a></li><li><a class="tocitem" href="../../mpc/methods/">Methods</a></li></ul></li><li><span class="tocitem">Developer</span><ul><li><a class="tocitem" href="../concept/">Design Concepts for the REopt Module</a></li><li><a class="tocitem" href="../organization/">File Organization</a></li><li><a class="tocitem" href="../inputs/">The REoptInputs structure</a></li><li class="is-active"><a class="tocitem" href>Adding a Technology</a><ul class="internal"><li><a class="tocitem" href="#.-Mathematical-Model"><span>1. Mathematical Model</span></a></li><li><a class="tocitem" href="#.-User-Inputs"><span>2. User Inputs</span></a></li><li><a class="tocitem" href="#.-REopt-Inputs"><span>3. REopt Inputs</span></a></li><li><a class="tocitem" href="#.-Results"><span>4. Results</span></a></li><li><a class="tocitem" href="#.-Testing-the-new-technology"><span>5. Testing the new technology</span></a></li></ul></li><li><a class="tocitem" href="../documentation/">Documenting the Code</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Developer</a></li><li class="is-active"><a href>Adding a Technology</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Adding a Technology</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/NREL/REopt.jl/blob/master/docs/src/developer/adding_tech.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Adding-a-Technology"><a class="docs-heading-anchor" href="#Adding-a-Technology">Adding a Technology</a><a id="Adding-a-Technology-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-a-Technology" title="Permalink"></a></h1><p>REopt can be used in many ways, but its primary use is to evaluate the techno-economic feasibility of energy generation and storage technologies. In this section we describe how one might add a new technology to the REopt model for evaluation. At a high level the steps are:</p><ol><li>Define the mathematical model for how the technology will interact with the other technologies, which includes:<ul><li>defining appropriate decision variables (the technology&#39;s capacity for example)</li><li>defining model constraints (operational constraints for example)</li></ul></li><li>Define the inputs and default values necessary to model the technology in the mathematical model</li><li>Map the input values to the sets and coefficients needed in the mathematical model</li><li>Create an adapter function to output the desired results from the mathematical model</li><li>Test the new technology</li></ol><p>All steps are not necessarily executed in this order and in fact most likely must be done in concert. For example, in order to define a model constraint one must define the input parameters. Also, it is good practice to think of how you will test the new technology from the very beginning of the design process and incrementally test your additions to the model as well as make sure that no existing tests fail due to your modifications to REopt.</p><h2 id=".-Mathematical-Model"><a class="docs-heading-anchor" href="#.-Mathematical-Model">1. Mathematical Model</a><a id=".-Mathematical-Model-1"></a><a class="docs-heading-anchor-permalink" href="#.-Mathematical-Model" title="Permalink"></a></h2><p>Each technology will have unique decision variables and constraints. However, there are some decision variables that apply to many technologies. We will use the <code>PV</code> technology to demonstrate some variables and constraints that are shared among all generation technologies and some that are unique to <code>PV</code>.</p><p>First, the <code>PV</code> technology can meet electrical demand and thus is part of the <code>techs.elec</code>. By including the <code>PV</code> technology in the set of <code>techs.elec</code> we can take advantage of existing model constraints such as the electrical load balance:</p><pre><code class="language-julia">@constraint(m, [ts in p.time_steps_with_grid],
    sum(p.production_factor[t, ts] * p.levelization_factor[t] * m[Symbol(&quot;dvRatedProduction&quot;*_n)][t,ts] for t in p.techs.elec) 
    + sum( m[Symbol(&quot;dvDischargeFromStorage&quot;*_n)][b,ts] for b in p.s.storage.types.elec ) 
    + sum(m[Symbol(&quot;dvGridPurchase&quot;*_n)][ts, tier] for tier in 1:p.s.electric_tariff.n_energy_tiers) 
    ==
    sum( sum(m[Symbol(&quot;dvProductionToStorage&quot;*_n)][b, t, ts] for b in p.s.storage.types.elec) 
    + m[Symbol(&quot;dvCurtail&quot;*_n)][t, ts] for t in p.techs.elec)
    + sum(m[Symbol(&quot;dvGridToStorage&quot;*_n)][b, ts] for b in p.s.storage.types.elec)
    + p.s.electric_load.loads_kw[ts]
)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Throughout the REopt code <code>p</code> is used as the variable name for the concrete instance of <code>REoptInputs</code>. The <code>p</code> is a legacy name from when the <code>REoptInputs</code> was called a <strong>p</strong>arameter structure. Also, <code>m</code> is used throughout the code for the JuMP Model and <code>p.s</code> is the <code>Scenario</code> structure.</p></div></div><p>From the load balance constraint we can see that the <code>PV</code> technology (and each <code>techs.elec</code>) includes input parameters for the <code>production_factor</code> and <code>levelization_factor</code>, and that the <code>PV</code> technology has the decision variables <code>dvRatedProduction</code> and <code>dvCurtail</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>All decision variables in the model start with <code>dv</code> and use camel case naming after <code>dv</code>. Also, in order to take advantage of dynamic variable names for multinode models we use the <code>Symbol</code> notation (e.g. <code>m[Symbol(&quot;dvProductionToStorage&quot;*_n)</code>) to define and access variables in the model.</p></div></div><p>The <code>p.techs</code> data structure is defined as follows:</p><h3 id="Techs"><a class="docs-heading-anchor" href="#Techs">Techs</a><a id="Techs-1"></a><a class="docs-heading-anchor-permalink" href="#Techs" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="REopt.Techs" href="#REopt.Techs"><code>REopt.Techs</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Techs</code></pre><p><code>Techs</code> contains the index sets that are used to define the model constraints and decision variables.</p><pre><code class="language-julia">mutable struct Techs
    all::Vector{String}
    elec::Vector{String}
    pv::Vector{String}
    gen::Vector{String}
    pbi::Vector{String}
    no_curtail::Vector{String}
    no_turndown::Vector{String}
    segmented::Vector{String}
    heating::Vector{String}
    cooling::Vector{String}
    boiler::Vector{String}
    fuel_burning::Vector{String}
    thermal::Vector{String}
    chp::Vector{String}
    requiring_oper_res::Vector{String}
    providing_oper_res::Vector{String}
    electric_chiller::Vector{String}
    absorption_chiller::Vector{String}
    steam_turbine::Vector{String}
    can_supply_steam_turbine::Vector{String}
    electric_heater::Vector{String}    
    can_serve_space_heating::Vector{String}
    can_serve_dhw::Vector{String}
    can_serve_process_heat::Vector{String}
    ghp::Vector{String}
    ashp::Vector{String}
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/REopt.jl/blob/8e8411669475eedbe4a41f4eb577f08dc5a6b0aa/src/core/types.jl#L17-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="REopt.Techs-Tuple{Scenario}" href="#REopt.Techs-Tuple{Scenario}"><code>REopt.Techs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Techs(s::Scenario)</code></pre><p>Create a <code>Techs</code> struct for the REoptInputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/REopt.jl/blob/8e8411669475eedbe4a41f4eb577f08dc5a6b0aa/src/core/techs.jl#L97-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="REopt.Techs-Tuple{REoptInputs, BAUScenario}" href="#REopt.Techs-Tuple{REoptInputs, BAUScenario}"><code>REopt.Techs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Techs(p::REoptInputs, s::BAUScenario)</code></pre><p>Create a <code>Techs</code> struct for the BAUInputs</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL/REopt.jl/blob/8e8411669475eedbe4a41f4eb577f08dc5a6b0aa/src/core/techs.jl#L2-L6">source</a></section></article><p>From the <a href="#Techs">Techs</a> definition we can see that there are already a lot of different energy generation technology categories in REopt. Adding a new technology to the model could be as simple as adding the appropriate inputs to <code>REoptInputs</code> (described in the next section) and using the <code>Techs</code> structure to define which variables and constraints apply to the new technology.</p><p>The <code>PV</code> technology is also part of a unique set of <code>Techs</code>, namely the <code>techs.pv</code> (there can be multiple <code>PV</code> technologies in a single model as we will see soon). An example of a constraint applied over <code>techs.pv</code> is:</p><pre><code class="language-julia">@constraint(m, [loc in p.pvlocations],
    sum(m[Symbol(&quot;dvSize&quot;*_n)][t] * p.pv_to_location[t][loc] for t in p.techs.pv) &lt;= p.maxsize_pv_locations[loc]
)</code></pre><p>Here we can see that the <code>dvSize</code> for each <code>techs.pv</code> is constrained based on the location of each <code>PV</code> technology. This constraint allows us to uniquely limit the <code>PV</code> capacity for roof mounted systems vs. ground mounted systems based on the available space at a site. We also see some additional inputs for the <code>PV</code> technology, such as the <code>pvlocations</code> and <code>maxsize_pv_locations</code>. Creating these input values is described in the next two sections.</p><h2 id=".-User-Inputs"><a class="docs-heading-anchor" href="#.-User-Inputs">2. User Inputs</a><a id=".-User-Inputs-1"></a><a class="docs-heading-anchor-permalink" href="#.-User-Inputs" title="Permalink"></a></h2><p>Any new technology should have a <code>technologyname.jl</code> file in the <code>src/core</code> directory. For example, in the <code>src/core/pv.jl</code> file we have a data structure and constructor for defining default values and creating the <code>PV</code> structure that is attached to the <a href="../../reopt/inputs/#Scenario">Scenario</a>. Once the new technology&#39;s data structure is defined it must be added to the <code>Scenario</code> structure (see <code>src/core/scenario.jl</code>). </p><p>When adding a new technology to REopt one must decide on how a user of the REopt will define the technology. Continuing with the <code>PV</code> example we saw that we need to define the <code>production_factor</code> for the <code>PV</code> technology in every time step. The <code>production_factor</code> varies from zero to one and defines the availability of the technology. For <code>PV</code> we have a default method for creating the <code>production_factor</code> as well as allow the user to provide their own <code>production_factor</code>.</p><p>We let the user define the <code>production_factor</code> by providing the <code>PV</code>s <code>production_factor_series</code> input in their JSON file or dictionary when creating their <a href="../../reopt/inputs/#Scenario">Scenario</a>. If the user does not provide a value for <code>production_factor_series</code> then we use the PVWatts API to get a <code>production_factor</code> based on the <code>Site.latitude</code> and <code>Site.longitude</code>. The <a href="../../reopt/inputs/#PV">PV</a> inputs structure also allows the user to change the arguments that are passed to PVWatts.</p><h2 id=".-REopt-Inputs"><a class="docs-heading-anchor" href="#.-REopt-Inputs">3. REopt Inputs</a><a id=".-REopt-Inputs-1"></a><a class="docs-heading-anchor-permalink" href="#.-REopt-Inputs" title="Permalink"></a></h2><p>The <a href="../inputs/#REoptInputs">REoptInputs</a> constructor is the work-horse for defining all the mathematical model parameters. It converts the user&#39;s <a href="../../reopt/inputs/#Scenario">Scenario</a> into a format that is necessary for adding the model decision variables and constraints.</p><p>A major part of the <a href="../inputs/#REoptInputs">REoptInputs</a> constructor is creating arrays that are indexed on sets of strings (defined in <a href="#Techs">Techs</a>) that allow us to define constraints all applicable technologies. Continuing with the <code>PV</code> example, the electrical load balance constraint includes:</p><pre><code class="language-julia">sum(p.production_factor[t, ts] * p.levelization_factor[t] * m[Symbol(&quot;dvRatedProduction&quot;*_n)][t,ts] for t in p.techs.elec) </code></pre><p>which implies that we need to define a <code>production_factor</code> for all <code>techs.elec</code> in every time step <code>ts</code>. To create the <code>production_factor</code> array the <a href="../inputs/#REoptInputs">REoptInputs</a> constructor first creates an empty array like so:</p><pre><code class="language-julia">production_factor = DenseAxisArray{Float64}(undef, techs.all, 1:length(s.electric_load.loads_kw))</code></pre><p>and then passes that array to technology specific functions that add their production factors to the <code>production_factor</code> array. For example, for <code>PV</code> within the <code>setup_pv_inputs</code> method we have:</p><pre><code class="language-julia">for pv in s.pvs
    production_factor[pv.name, :] = get_production_factor(pv, s.site.latitude, s.site.longitude)
    ...
end</code></pre><p>The completed <code>production_factor</code> array is then attached to the <code>REoptInputs</code> structure so that it can be used as needed to create the mathematical model.</p><h2 id=".-Results"><a class="docs-heading-anchor" href="#.-Results">4. Results</a><a id=".-Results-1"></a><a class="docs-heading-anchor-permalink" href="#.-Results" title="Permalink"></a></h2><p>After adding a new technology to the REopt mathematical model and getting the new inputs set up you can create some results from the optimized model. Some or all of your new results can also be used in a test for the new technology.</p><p>All of the results methods are defined in <code>src/results</code>, with <code>src/results/results.jl</code> containing the main method for creating results. The results are returned to the user as a dictionary. If a user is not modeling your new technology then there is no reason to create any new results. Therefore, in <code>reopt_results</code> we have:</p><pre><code class="language-julia">if !isempty(p.techs.pv)
    add_pv_results(m, p, d; _n)
end</code></pre><p>which uses the model <code>m</code> and the <code>REoptInputs</code> <code>p</code> to add results to the dictionary <code>d</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>_n</code> argument is used in many places in REopt to optionally modeled multinode scenarios. The default value for <code>_n</code> is an empty string. When modeling multiple nodes the <code>n</code> in the <code>_n</code> string is set to the <code>Site.node</code> value, which is an integer. For example, if the <code>Site.node</code> is <code>3</code> then <code>_n = &quot;_3&quot;</code>.</p></div></div><h2 id=".-Testing-the-new-technology"><a class="docs-heading-anchor" href="#.-Testing-the-new-technology">5. Testing the new technology</a><a id=".-Testing-the-new-technology-1"></a><a class="docs-heading-anchor-permalink" href="#.-Testing-the-new-technology" title="Permalink"></a></h2><p>Adding a new test is not necessarily the last step in adding a technology to the REopt model. In fact, it is best to use a simple test to test your code as you add the new technolgy and then adapt the test as you add more capability to the code. For example, once you have created you new technology&#39;s input interface you can test just creating a <code>Scenario</code> with the new technology by passing the path to a JSON file that contains the minimum required inputs for a Scenario and your new technology. This might look like:</p><pre><code class="language-julia">@testset &quot;My new technology&quot; begin
    s = Scenario(&quot;path/to/mynewtech.json&quot;)
end</code></pre><p>The next testing step might be checking the <code>REoptInputs</code> additions for your new technolgy:</p><pre><code class="language-julia">@testset &quot;My new technology&quot; begin
    s = Scenario(&quot;path/to/mynewtech.json&quot;)
    p = REoptInputs(s)
end</code></pre><p>Once you have all of your new inputs set up you can test the model creation with:</p><pre><code class="language-julia">@testset &quot;My new technology&quot; begin
    m = Model(Cbc.Optimizer)
    build_reopt!(m, &quot;path/to/mynewtech.json&quot;)
end</code></pre><p>Finally, you can test the full work-flow with something like:</p><pre><code class="language-julia">@testset &quot;My new technology&quot; begin
    m = Model(Cbc.Optimizer)
    results = run_reopt(m, &quot;path/to/mynewtech.json&quot;)
    @test results[&quot;mynewtech&quot;][&quot;some_result&quot;] ≈ 78.9 atol=0.1
end</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../inputs/">« The REoptInputs structure</a><a class="docs-footer-nextpage" href="../documentation/">Documenting the Code »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 26 February 2025 15:54">Wednesday 26 February 2025</span>. Using Julia version 1.10.8.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
