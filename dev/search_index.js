var documenterSearchIndex = {"docs":
[{"location":"mpc/examples/#MPC-Examples","page":"MPC Examples","title":"MPC Examples","text":"","category":"section"},{"location":"mpc/examples/","page":"MPC Examples","title":"MPC Examples","text":"The MPC capability provided by REopt is essentially the optimal sizing and dispatch capability that REopt is commonly used for, but with the sizing problem removed. Also, the MPC model can be built for an arbitrary time length, or \"horizon\" (whereas a REopt model always includes an entire calendar year). The MPC model also requires the user to provide load and resource forecasts as inputs (whereas the typical REopt model allows one to use built-in load profiles as well as other API's such as PVWatts for the solar resource).","category":"page"},{"location":"mpc/examples/","page":"MPC Examples","title":"MPC Examples","text":"using REopt, JuMP, Cbc\nmodel = Model(Cbc.Optimizer)\nresults = run_mpc(model, \"./test/scenarios/mpc.json\")","category":"page"},{"location":"mpc/examples/","page":"MPC Examples","title":"MPC Examples","text":"See mpc.json for details on the Scenario.","category":"page"},{"location":"reopt/outputs/#Outputs","page":"Outputs","title":"Outputs","text":"","category":"section"},{"location":"reopt/outputs/#Financial-outputs","page":"Outputs","title":"Financial outputs","text":"","category":"section"},{"location":"reopt/outputs/","page":"Outputs","title":"Outputs","text":"REopt.add_financial_results","category":"page"},{"location":"reopt/outputs/#REopt.add_financial_results","page":"Outputs","title":"REopt.add_financial_results","text":"add_financial_results(m::JuMP.AbstractModel, p::REoptInputs, d::Dict; _n=\"\")\n\nAdds the Financial results to the dictionary passed back from run_reopt using the solved model m and the REoptInputs for node _n. Note: the node number is an empty string if evaluating a single Site.\n\nFinancial results:\n\nlcc Optimal lifecycle cost\nlifecycle_capital_costs_plus_om Capital cost for all technologies plus present value of operations and maintenance over anlaysis period\nlifecycle_capital_costs Net capital costs for all technologies, in present value, including replacement costs and incentives.\n\n\n\n\n\n","category":"function"},{"location":"reopt/outputs/#ElectricTariff-outputs","page":"Outputs","title":"ElectricTariff outputs","text":"","category":"section"},{"location":"reopt/outputs/","page":"Outputs","title":"Outputs","text":"REopt.add_electric_tariff_results","category":"page"},{"location":"reopt/outputs/#REopt.add_electric_tariff_results","page":"Outputs","title":"REopt.add_electric_tariff_results","text":"add_electric_tariff_results(m::JuMP.AbstractModel, p::REoptInputs, d::Dict; _n=\"\")\n\nAdds the ElectricTariff results to the dictionary passed back from run_reopt using the solved model m and the REoptInputs for node _n. Note: the node number is an empty string if evaluating a single Site.\n\nElectricTariff results:\n\nlifecycle_energy_cost lifecycle cost of energy from the grid in present value, after tax\nyear_one_energy_cost cost of energy from the grid over the first year\nlifecycle_demand_cost lifecycle cost of power from the grid in present value, after tax\nyear_one_demand_cost cost of power from the grid over the first year\nlifecycle_fixed_cost lifecycle fixed cost in present value, after tax\nyear_one_fixed_cost fixed cost over the first year\nlifecycle_min_charge_adder lifecycle minimum charge in present value, after tax\nyear_one_min_charge_adder minimum charge over the first year\nyear_one_bill sum of year_one_energy_cost, year_one_demand_cost, year_one_fixed_cost, year_one_min_charge_adder, and year_one_coincident_peak_cost\nlifecycle_export_benefit lifecycle export credits in present value, after tax\nyear_one_export_benefit export credits over the first year\nlifecycle_coincident_peak_cost lifecycle coincident peak charge in present value\nyear_one_coincident_peak_cost coincident peak charge over the first year\n\n\n\n\n\n","category":"function"},{"location":"reopt/outputs/#ElectricLoad-outputs","page":"Outputs","title":"ElectricLoad outputs","text":"","category":"section"},{"location":"reopt/outputs/","page":"Outputs","title":"Outputs","text":"REopt.add_electric_load_results","category":"page"},{"location":"reopt/outputs/#REopt.add_electric_load_results","page":"Outputs","title":"REopt.add_electric_load_results","text":"add_electric_load_results(m::JuMP.AbstractModel, p::REoptInputs, d::Dict; _n=\"\")\n\nAdds the ElectricLoad results to the dictionary passed back from run_reopt using the solved model m and the REoptInputs for node _n. Note: the node number is an empty string if evaluating a single Site.\n\nElectricLoad results:\n\nload_series_kw vector of site load in every time step\ncritical_load_series_kw vector of site critical load in every time step\nannual_calculated_kwh sum of the load_series_kw\n\n\n\n\n\n","category":"function"},{"location":"reopt/outputs/#ElectricUtility-outputs","page":"Outputs","title":"ElectricUtility outputs","text":"","category":"section"},{"location":"reopt/outputs/","page":"Outputs","title":"Outputs","text":"REopt.add_electric_utility_results","category":"page"},{"location":"reopt/outputs/#REopt.add_electric_utility_results","page":"Outputs","title":"REopt.add_electric_utility_results","text":"add_electric_utility_results(m::JuMP.AbstractModel, p::REoptInputs, d::Dict; _n=\"\")\n\nAdds the ElectricUtility results to the dictionary passed back from run_reopt using the solved model m and the REoptInputs for node _n. Note: the node number is an empty string if evaluating a single Site.\n\nElectricUtility results:\n\nyear_one_energy_supplied_kwh Total energy supplied from the grid in year one.\nyear_one_to_load_series_kw Vector of powers drawn from the grid to serve load in year one.\nyear_one_to_battery_series_kw Vector of powers drawn from the grid to charge the battery in year one.\n\n\n\n\n\n","category":"function"},{"location":"reopt/outputs/#PV-outputs","page":"Outputs","title":"PV outputs","text":"","category":"section"},{"location":"reopt/outputs/","page":"Outputs","title":"Outputs","text":"REopt.add_pv_results","category":"page"},{"location":"reopt/outputs/#REopt.add_pv_results","page":"Outputs","title":"REopt.add_pv_results","text":"add_pv_results(m::JuMP.AbstractModel, p::REoptInputs, d::Dict; _n=\"\")\n\nAdds the PV results to the dictionary passed back from run_reopt using the solved model m and the REoptInputs for node _n. Note: the node number is an empty string if evaluating a single Site.\n\nwarn: Warn\nThe key(s) used to access PV outputs in the results dictionary is determined by the PV.name value to allow for modeling multiple PV options. (The default PV.name is \"PV\".)\n\nPV results:\n\nsize_kw Optimal PV capacity\nlifecycle_om_cost Lifecycle operations and maintenance cost in present value, after tax\nyear_one_energy_produced_kwh Energy produced over the first year\naverage_annual_energy_produced_kwh Average annual energy produced when accounting for degradation\nlcoe_per_kwh Levelized Cost of Energy produced by the PV system\nyear_one_to_load_series_kw Vector of power used to meet load over the first year\nyear_one_to_battery_series_kw Vector of power used to charge the battery over the first year\nyear_one_to_grid_series_kw Vector of power exported to the grid over the first year\nyear_one_curtailed_production_series_kw Vector of power curtailed over the first year\naverage_annual_energy_exported_kwh Average annual energy exported to the grid\n\n\n\n\n\n","category":"function"},{"location":"reopt/outputs/#Wind-outputs","page":"Outputs","title":"Wind outputs","text":"","category":"section"},{"location":"reopt/outputs/","page":"Outputs","title":"Outputs","text":"REopt.add_wind_results","category":"page"},{"location":"reopt/outputs/#REopt.add_wind_results","page":"Outputs","title":"REopt.add_wind_results","text":"add_wind_results(m::JuMP.AbstractModel, p::REoptInputs, d::Dict; _n=\"\")\n\nAdds the Wind results to the dictionary passed back from run_reopt using the solved model m and the REoptInputs for node _n. Note: the node number is an empty string if evaluating a single Site.\n\nWind results:\n\nsize_kw Optimal Wind capacity\nlifecycle_om_cost Lifecycle operations and maintenance cost in present value, after tax\nyear_one_om_cost Operations and maintenance cost in the first year\nyear_one_to_battery_series_kw Vector of power used to charge the battery over the first year\nyear_one_to_grid_series_kw Vector of power exported to the grid over the first year\naverage_annual_energy_exported_kwh Average annual energy exported to the grid\nyear_one_to_load_series_kw Vector of power used to meet load over the first year\nyear_one_energy_produced_kwh Energy produced over the first year\naverage_annual_energy_produced_kwh Average annual energy produced when accounting for degradation\nlcoe_per_kwh Levelized Cost of Energy produced by the PV system\nyear_one_curtailed_production_series_kw Vector of power curtailed over the first year\n\n\n\n\n\n","category":"function"},{"location":"reopt/outputs/#ElectricStorage-outputs","page":"Outputs","title":"ElectricStorage outputs","text":"","category":"section"},{"location":"reopt/outputs/","page":"Outputs","title":"Outputs","text":"REopt.add_electric_storage_results","category":"page"},{"location":"reopt/outputs/#REopt.add_electric_storage_results","page":"Outputs","title":"REopt.add_electric_storage_results","text":"add_electric_storage_results(m::JuMP.AbstractModel, p::REoptInputs, d::Dict; _n=\"\")\n\nAdds the Storage results to the dictionary passed back from run_reopt using the solved model m and the REoptInputs for node _n. Note: the node number is an empty string if evaluating a single Site.\n\nStorage results:\n\nsize_kw Optimal inverter capacity\nsize_kwh Optimal storage capacity\nyear_one_soc_series_pct Vector of normalized (0-1) state of charge values over the first year\nyear_one_to_load_series_kw Vector of power used to meet load over the first year\nyear_one_to_grid_series_kw Vector of power exported to the grid over the first year\n\n\n\n\n\n","category":"function"},{"location":"reopt/outputs/#HotThermalStorage-outputs","page":"Outputs","title":"HotThermalStorage outputs","text":"","category":"section"},{"location":"reopt/outputs/","page":"Outputs","title":"Outputs","text":"REopt.add_hot_storage_results","category":"page"},{"location":"reopt/outputs/#REopt.add_hot_storage_results","page":"Outputs","title":"REopt.add_hot_storage_results","text":"add_hot_storage_results(m::JuMP.AbstractModel, p::REoptInputs, d::Dict; _n=\"\")\n\nAdds the Storage results to the dictionary passed back from run_reopt using the solved model m and the REoptInputs for node _n. Note: the node number is an empty string if evaluating a single Site.\n\nStorage results:\n\nsize_gal Optimal TES capacity, by volume [gal]\nyear_one_soc_series_pct Vector of normalized (0-1) state of charge values over the first year [-]\nyear_one_to_load_series_mmbtu_per_hour Vector of power used to meet load over the first year [MMBTU/hr]\n\n\n\n\n\n","category":"function"},{"location":"reopt/outputs/#ColdThermalStorage-outputs","page":"Outputs","title":"ColdThermalStorage outputs","text":"","category":"section"},{"location":"reopt/outputs/","page":"Outputs","title":"Outputs","text":"REopt.add_cold_storage_results","category":"page"},{"location":"reopt/outputs/#REopt.add_cold_storage_results","page":"Outputs","title":"REopt.add_cold_storage_results","text":"add_cold_storage_results(m::JuMP.AbstractModel, p::REoptInputs, d::Dict; _n=\"\")\n\nAdds the Storage results to the dictionary passed back from run_reopt using the solved model m and the REoptInputs for node _n. Note: the node number is an empty string if evaluating a single Site.\n\nStorage results:\n\nsize_gal Optimal TES capacity, by volume [gal]\nyear_one_soc_series_pct Vector of normalized (0-1) state of charge values over the first year [-]\nyear_one_to_load_series_ton Vector of power used to meet load over the first year [ton]\n\n\n\n\n\n","category":"function"},{"location":"reopt/outputs/#Generator-outputs","page":"Outputs","title":"Generator outputs","text":"","category":"section"},{"location":"reopt/outputs/","page":"Outputs","title":"Outputs","text":"REopt.add_generator_results","category":"page"},{"location":"reopt/outputs/#REopt.add_generator_results","page":"Outputs","title":"REopt.add_generator_results","text":"add_generator_results(m::JuMP.AbstractModel, p::REoptInputs, d::Dict; _n=\"\")\n\nAdds the Generator results to the dictionary passed back from run_reopt using the solved model m and the REoptInputs for node _n. Note: the node number is an empty string if evaluating a single Site.\n\nGenerator results:\n\nsize_kw Optimal generator capacity\nlifecycle_fixed_om_cost Lifecycle fixed operations and maintenance cost in present value, after tax\nyear_one_fixed_om_cost fixed operations and maintenance cost over the first year\nlifecycle_variable_om_cost Lifecycle variable operations and maintenance cost in present value, after tax\nyear_one_variable_om_cost variable operations and maintenance cost over the first year\nlifecycle_fuel_cost Lifecycle fuel cost in present value, after tax\nyear_one_fuel_cost Fuel cost over the first year\nfuel_used_gal Gallons of fuel used in each year\nyear_one_to_battery_series_kw Vector of power sent to battery in year one\nyear_one_to_grid_series_kw Vector of power sent to grid in year one\nyear_one_to_load_series_kw Vector of power sent to load in year one\nyear_one_energy_produced_kwh Total energy produced in year one\naverage_annual_energy_produced_kwh Average annual energy produced over analysis period\n\n\n\n\n\n","category":"function"},{"location":"reopt/outputs/#CHP-outputs","page":"Outputs","title":"CHP outputs","text":"","category":"section"},{"location":"reopt/outputs/","page":"Outputs","title":"Outputs","text":"REopt.add_chp_results","category":"page"},{"location":"reopt/outputs/#REopt.add_chp_results","page":"Outputs","title":"REopt.add_chp_results","text":"add_chp_results(m::JuMP.AbstractModel, p::REoptInputs, d::Dict; _n=\"\")\n\nAdds the CHP results to the dictionary passed back from run_reopt using the solved model m and the REoptInputs for node _n. Note: the node number is an empty string if evaluating a single Site.\n\nCHP results:\n\nsize_kw Power capacity size of the CHP system [kW]\nsize_supplemental_firing_kw Power capacity of CHP supplementary firing system [kW]\nyear_one_fuel_used_mmbtu Fuel consumed in year one [MMBtu]\nyear_one_electric_energy_produced_kwh Electric energy produced in year one [kWh]\nyear_one_thermal_energy_produced_mmbtu Thermal energy produced in year one [MMBtu]\nyear_one_electric_production_series_kw Electric power production time-series array [kW]\nyear_one_to_grid_series_kw Electric power exported time-series array [kW]\nyear_one_to_battery_series_kw Electric power to charge the battery storage time-series array [kW]\nyear_one_to_load_series_kw Electric power to serve the electric load time-series array [kW]\nyear_one_thermal_to_waste_series_mmbtu_per_hour Thermal power wasted/unused/vented time-series array [MMBtu/hr]\nyear_one_thermal_to_load_series_mmbtu_per_hour Thermal power to serve the heating load time-series array [MMBtu/hr]\nyear_one_chp_fuel_cost Fuel cost from fuel consumed by the CHP system [$]\nlifecycle_chp_fuel_cost Fuel cost from fuel consumed by the CHP system [$]\n\n\n\n\n\n","category":"function"},{"location":"reopt/outputs/#Uncertain-Outages-outputs","page":"Outputs","title":"Uncertain Outages outputs","text":"","category":"section"},{"location":"reopt/outputs/","page":"Outputs","title":"Outputs","text":"REopt.add_outage_results","category":"page"},{"location":"reopt/outputs/#REopt.add_outage_results","page":"Outputs","title":"REopt.add_outage_results","text":"add_outage_results(m::JuMP.AbstractModel, p::REoptInputs, d::Dict)\n\nAdds the Outages results to the dictionary passed back from run_reopt using the solved model m and the REoptInputs. Only added to results when multiple outages are modeled via the ElectricUtility.outage_durations input.\n\nnote: Note\nWhen modeling PV the name of the PV system is used for the output keys to allow for modeling multiple PV systems. The default PV name is PV.\n\nwarn: Warn\nThe Outage results can be very large when many outages are modeled and can take a long time to generate.\n\nOutages results:\n\nexpected_outage_cost The expected outage cost over the random outages modeled.\nmax_outage_cost_per_outage_duration_series The maximum outage cost in every outage duration modeled.\nunserved_load_series The amount of unserved load in each outage and each time step.\nunserved_load_per_outage_series The total unserved load in each outage.\nmg_storage_upgrade_cost The cost to include the storage system in the microgrid.\nstorage_upgraded Boolean that is true if it is cost optimal to include the storage system in the microgrid.\n\n= discharge_from_storage_series Array of storage power discharged in every outage modeled.\n\nPVmg_kw Optimal microgrid PV capacity. Note that the name PV can change based on user provided PV.name.\nmg_PV_upgrade_cost The cost to include the PV system in the microgrid.\nmgPV_to_storage_series Array of PV power sent to the battery in every outage modeled.\nmgPV_curtailed_series Array of PV curtailed in every outage modeled.\nmgPV_to_load_series Array of PV power used to meet load in every outage modeled.\nGeneratormg_kw Optimal microgrid Generator capacity. Note that the name Generator can change based on user provided Generator.name.\nmg_Generator_upgrade_cost The cost to include the Generator system in the microgrid.\nmgGenerator_to_storage_series Array of Generator power sent to the battery in every outage modeled.\nmgGenerator_curtailed_series Array of Generator curtailed in every outage modeled.\nmgGenerator_to_load_series Array of Generator power used to meet load in every outage modeled.\nmg_Generator_fuel_used Array of Generator fuel used in every outage modeled.\n\nwarn: Warn\nThe output keys for \"Outages\" are subject to change.\n\n\n\n\n\n","category":"function"},{"location":"developer/organization/#File-Organization","page":"File Organization","title":"File Organization","text":"","category":"section"},{"location":"developer/organization/#data","page":"File Organization","title":"data","text":"","category":"section"},{"location":"developer/organization/","page":"File Organization","title":"File Organization","text":"Contains static input values such as the DoE Commercial Reference Building load profiles","category":"page"},{"location":"developer/organization/#docs","page":"File Organization","title":"docs","text":"","category":"section"},{"location":"developer/organization/","page":"File Organization","title":"File Organization","text":"Contains all of the files for constructing this package's documentation.","category":"page"},{"location":"developer/organization/#src","page":"File Organization","title":"src","text":"","category":"section"},{"location":"developer/organization/","page":"File Organization","title":"File Organization","text":"All of the code necessary for this package.","category":"page"},{"location":"developer/organization/#src/constraints","page":"File Organization","title":"src/constraints","text":"","category":"section"},{"location":"developer/organization/","page":"File Organization","title":"File Organization","text":"Mathematical model constraints organized by which high-level structures they primarily impact.","category":"page"},{"location":"developer/organization/#src/core","page":"File Organization","title":"src/core","text":"","category":"section"},{"location":"developer/organization/","page":"File Organization","title":"File Organization","text":"The code that is central to this package. These files are used to build the inputs and the JuMP model. Some highlights:","category":"page"},{"location":"developer/organization/","page":"File Organization","title":"File Organization","text":"scenario.jl is the entry point for user's inputs. It uses many of the other files in the core directory to construct the high level inputs (such electric_load.jl, financial.jl, and electric_tariff.jl).\nreopt_inputs.jl uses the Scenario to construct the inputs necessary to build the JuMP model\nreopt.jl contains the methods for building and runnning the mathematical model","category":"page"},{"location":"developer/organization/#src/lindistflow","page":"File Organization","title":"src/lindistflow","text":"","category":"section"},{"location":"developer/organization/","page":"File Organization","title":"File Organization","text":"Code for adding a LinDistFlow model to a multi-node REopt model.","category":"page"},{"location":"developer/organization/#src/mpc","page":"File Organization","title":"src/mpc","text":"","category":"section"},{"location":"developer/organization/","page":"File Organization","title":"File Organization","text":"A Model Predictive Control implementation of REopt.","category":"page"},{"location":"developer/organization/#src/outagesim","page":"File Organization","title":"src/outagesim","text":"","category":"section"},{"location":"developer/organization/","page":"File Organization","title":"File Organization","text":"The outage simulator code, which calculates some resilience metrics such as the probability of surviving varying outage durations.","category":"page"},{"location":"developer/organization/#src/results","page":"File Organization","title":"src/results","text":"","category":"section"},{"location":"developer/organization/","page":"File Organization","title":"File Organization","text":"All of the code for post-processing an optimized model and creating the results dictionary returned to the user.","category":"page"},{"location":"developer/organization/#src/sam","page":"File Organization","title":"src/sam","text":"","category":"section"},{"location":"developer/organization/","page":"File Organization","title":"File Organization","text":"System Advisor Model libraries used by this package for the Wind model.","category":"page"},{"location":"developer/organization/#test","page":"File Organization","title":"test","text":"","category":"section"},{"location":"developer/organization/","page":"File Organization","title":"File Organization","text":"Built-in tests for several different solvers.","category":"page"},{"location":"developer/organization/#transcrypt","page":"File Organization","title":"transcrypt","text":"","category":"section"},{"location":"developer/organization/","page":"File Organization","title":"File Organization","text":"A small executable for encrypting the xpauth.xpr license file that is used by NREL developers.","category":"page"},{"location":"mpc/inputs/#MPC-Inputs","page":"MPC Inputs","title":"MPC Inputs","text":"","category":"section"},{"location":"mpc/inputs/","page":"MPC Inputs","title":"MPC Inputs","text":"The input structure for MPC models is very similar to the structure for REopt Inputs. The primary differences are ","category":"page"},{"location":"mpc/inputs/","page":"MPC Inputs","title":"MPC Inputs","text":"The MPCElectricTariff requires specifying individual rate components (and does not parse URDB rates like ElectricTariff).\nThe capacities of any provided DER must be provided\nThe load profile for each time step must be provided","category":"page"},{"location":"mpc/inputs/","page":"MPC Inputs","title":"MPC Inputs","text":"Just like REopt Inputs, inputs to run_mpc can be provided in one of three formats:","category":"page"},{"location":"mpc/inputs/","page":"MPC Inputs","title":"MPC Inputs","text":"a file path (string) to a JSON file,\na Dict, or\nusing the MPCInputs struct","category":"page"},{"location":"mpc/inputs/","page":"MPC Inputs","title":"MPC Inputs","text":"The accepted keys for the JSON file or Dict are:","category":"page"},{"location":"mpc/inputs/","page":"MPC Inputs","title":"MPC Inputs","text":"ElectricLoad\nElectricTariff\nPV\nElectricStorage\nFinancial\nGenerator\nElectricUtility\nSettings","category":"page"},{"location":"mpc/inputs/","page":"MPC Inputs","title":"MPC Inputs","text":"The simplest scenario does not have any dispatch optimization and is essentially a cost \"calculator:","category":"page"},{"location":"mpc/inputs/","page":"MPC Inputs","title":"MPC Inputs","text":"{\n    \"ElectricLoad\": {\n        \"loads_kw\": [10.0, 11.0, 12.0]\n    },\n    \"ElectricTariff\": {\n        \"energy_rates\": [0.1, 0.2, 0.3]\n    }\n}","category":"page"},{"location":"mpc/inputs/","page":"MPC Inputs","title":"MPC Inputs","text":"note: Note\nThe ElectricLoad.loads_kw can have an arbitrary length, but its length must be the same lengths as many other inputs such as the MPCElectricTariff.energy_rates and the PV.prod_factor_series.","category":"page"},{"location":"mpc/inputs/","page":"MPC Inputs","title":"MPC Inputs","text":"Here is a more complex MPCScenario, which is used in MPC Examples:","category":"page"},{"location":"mpc/inputs/","page":"MPC Inputs","title":"MPC Inputs","text":"{\n    \"PV\": {\n        \"size_kw\": 150,\n        \"prod_factor_series\": [\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n            0.05,\n            0.10,\n            0.15,\n            0.30,\n            0.6,\n            0.5,\n            0.3,\n            0.02,\n            0.01,\n            0.005,\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n            0.0,\n            0.0\n        ]\n    },\n    \"ElectricStorage\": {\n        \"size_kw\": 30.0,\n        \"size_kwh\": 60.0,\n        \"can_grid_charge\": true\n    },\n    \"ElectricLoad\": {\n        \"loads_kw\": [\n            100,\n            100,\n            100,\n            100,\n            100,\n            100,\n            100,\n            100,\n            100,\n            100,\n            100,\n            100,\n            100,\n            100,\n            100,\n            100,\n            100,\n            100,\n            100,\n            100,\n            100,\n            100,\n            100,\n            100\n        ]\n    },\n    \"ElectricTariff\": {\n        \"energy_rates\": [\n            0.1,\n            0.1,\n            0.1,\n            0.1,\n            0.1,\n            0.1,\n            0.15,\n            0.15,\n            0.15,\n            0.15,\n            0.15,\n            0.15,\n            0.15,\n            0.2,\n            0.2,\n            0.2,\n            0.3,\n            0.2,\n            0.2,\n            0.2,\n            0.1,\n            0.1,\n            0.1,\n            0.1\n        ],\n        \"monthly_demand_rates\": [10.0],\n        \"monthly_previous_peak_demands\": [98.0],\n        \"tou_demand_rates\": [0.0, 15.0],\n        \"tou_demand_timesteps\": [\n            [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], \n            [16, 17, 18, 19, 20, 21, 22, 23, 24]\n        ],\n        \"tou_previous_peak_demands\": [98.0, 97.0],\n        \"net_metering\": false,\n        \"export_rates\": [0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, \n            0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05]\n    }\n}","category":"page"},{"location":"mpc/inputs/#MPC-Input-Structures","page":"MPC Inputs","title":"MPC Input Structures","text":"","category":"section"},{"location":"mpc/inputs/","page":"MPC Inputs","title":"MPC Inputs","text":"Note that the keys of the input Dict or JSON file do not need the MPC prefix. ","category":"page"},{"location":"mpc/inputs/#MPCElectricTariff","page":"MPC Inputs","title":"MPCElectricTariff","text":"","category":"section"},{"location":"mpc/inputs/","page":"MPC Inputs","title":"MPC Inputs","text":"REopt.MPCElectricTariff(d::Dict)","category":"page"},{"location":"mpc/inputs/#REopt.MPCElectricTariff-Tuple{Dict}","page":"MPC Inputs","title":"REopt.MPCElectricTariff","text":"MPCElectricTariff(d::Dict)\n\nfunction for parsing user inputs into \n\n    struct MPCElectricTariff\n        monthly_previous_peak_demands::Array{Float64,1}\n        energy_rates::Array{Float64,1} \n\n        monthly_demand_rates::Array{Float64,1}\n        time_steps_monthly::Array{Array{Int64,1},1}  # length = 0 or 12\n\n        tou_demand_rates::Array{Float64,1}\n        tou_demand_ratchet_timesteps::Array{Array{Int64,1},1}  # length = n_tou_demand_ratchets\n        tou_previous_peak_demands::Array{Float64,1}\n\n        fixed_monthly_charge::Float64\n        annual_min_charge::Float64\n        min_monthly_charge::Float64\n\n        export_rates::DenseAxisArray{Array{Float64,1}}\n        export_bins::Array{Symbol,1}\n    end\n\nKeys for d include:\n\nenergy_rates\nREQUIRED\nmust have length equal to ElectricLoad.loads_kw\nmonthly_demand_rates\ndefault = [0]\ntime_steps_monthly\narray of arrays for integer time steps that the monthly_demand_rates apply to\ndefault = [collect(1:length(energy_rates))]\nmonthly_previous_peak_demands\ndefault = [0]\ntou_demand_rates\nan array of time-of-use demand rates\nmust have length equal to tou_demand_timesteps\ndefault = []\ntou_demand_timesteps\nan array of arrays for the integer time steps that apply to the tou_demand_rates\ndefault = []\ntou_previous_peak_demands\nan array of the previous peak demands set in each time-of-use demand period\nmust have length equal to tou_demand_timesteps\ndefault = []\nnet_metering\nboolean, if true then customer DER export is compensated at the energy_rates\nexport_rates\ncan be a <:Real or Array{<:Real, 1}, or not provided\nif provided, customer DER export is compensated at the export_rates\n\nNOTE: if both net_metering=true and export_rates are provided then the model can choose from either option.\n\n\n\n\n\n","category":"method"},{"location":"mpc/inputs/#MPCElectricLoad","page":"MPC Inputs","title":"MPCElectricLoad","text":"","category":"section"},{"location":"mpc/inputs/","page":"MPC Inputs","title":"MPC Inputs","text":"REopt.MPCElectricLoad","category":"page"},{"location":"mpc/inputs/#REopt.MPCElectricLoad","page":"MPC Inputs","title":"REopt.MPCElectricLoad","text":"MPCElectricLoad\n\nBase.@kwdef struct MPCElectricLoad\n    loads_kw::Array{Real,1}\n    critical_loads_kw::Union{Missing, Array{Real,1}} = missing\nend\n\n\n\n\n\n","category":"type"},{"location":"mpc/inputs/#MPCElectricStorage","page":"MPC Inputs","title":"MPCElectricStorage","text":"","category":"section"},{"location":"mpc/inputs/","page":"MPC Inputs","title":"MPC Inputs","text":"REopt.MPCElectricStorage","category":"page"},{"location":"mpc/inputs/#REopt.MPCElectricStorage","page":"MPC Inputs","title":"REopt.MPCElectricStorage","text":"MPCElectricStorage\n\nBase.@kwdef struct MPCElectricStorage < AbstractElectricStorage\n    size_kw::Float64\n    size_kwh::Float64\n    charge_efficiency::Float64 =  0.96 * 0.975^2\n    discharge_efficiency::Float64 =  0.96 * 0.975^2\n    soc_min_pct::Float64 = 0.2\n    soc_init_pct::Float64 = 0.5\n    can_grid_charge::Bool = true\n    grid_charge_efficiency::Float64 = 0.96 * 0.975^2\nend\n\n\n\n\n\n","category":"type"},{"location":"mpc/inputs/#MPCFinancial","page":"MPC Inputs","title":"MPCFinancial","text":"","category":"section"},{"location":"mpc/inputs/","page":"MPC Inputs","title":"MPC Inputs","text":"REopt.MPCFinancial","category":"page"},{"location":"mpc/inputs/#REopt.MPCFinancial","page":"MPC Inputs","title":"REopt.MPCFinancial","text":"MPCFinancial\n\nBase.@kwdef struct MPCFinancial\n    value_of_lost_load_per_kwh::Union{Array{R,1}, R} where R<:Real = 1.00\nend\n\n\n\n\n\n","category":"type"},{"location":"mpc/inputs/#MPCPV","page":"MPC Inputs","title":"MPCPV","text":"","category":"section"},{"location":"mpc/inputs/","page":"MPC Inputs","title":"MPC Inputs","text":"REopt.MPCPV","category":"page"},{"location":"mpc/inputs/#REopt.MPCPV","page":"MPC Inputs","title":"REopt.MPCPV","text":"MPCPV\n\nBase.@kwdef struct MPCPV\n    name::String=\"PV\"\n    size_kw::Real = 0\n    prod_factor_series::Union{Missing, Array{Real,1}} = missing\nend\n\n\n\n\n\n","category":"type"},{"location":"mpc/inputs/#MPCGenerator","page":"MPC Inputs","title":"MPCGenerator","text":"","category":"section"},{"location":"mpc/inputs/","page":"MPC Inputs","title":"MPC Inputs","text":"REopt.MPCGenerator","category":"page"},{"location":"mpc/inputs/#REopt.MPCGenerator","page":"MPC Inputs","title":"REopt.MPCGenerator","text":"MPCGenerator\n\nstruct with inner constructor:\n\nfunction MPCGenerator(;\n    size_kw::Real,\n    fuel_cost_per_gallon::Float64 = 3.0,\n    fuel_slope_gal_per_kwh::Float64 = 0.076,\n    fuel_intercept_gal_per_hr::Float64 = 0.0,\n    fuel_avail_gal::Float64 = 660.0,\n    min_turn_down_pct::Float64 = 0.0,  # TODO change this to non-zero value\n    only_runs_during_grid_outage::Bool = true,\n    sells_energy_back_to_grid::Bool = false,\n    om_cost_per_kwh::Float64=0.0,\n    )\n\n\n\n\n\n","category":"type"},{"location":"mpc/inputs/#MPCSettings","page":"MPC Inputs","title":"MPCSettings","text":"","category":"section"},{"location":"mpc/inputs/","page":"MPC Inputs","title":"MPC Inputs","text":"The MPCSettings is the same as the Settings.","category":"page"},{"location":"mpc/inputs/#MPCLimits","page":"MPC Inputs","title":"MPCLimits","text":"","category":"section"},{"location":"mpc/inputs/","page":"MPC Inputs","title":"MPC Inputs","text":"REopt.MPCLimits","category":"page"},{"location":"mpc/inputs/#REopt.MPCLimits","page":"MPC Inputs","title":"REopt.MPCLimits","text":"MPCLimits\n\nstruct for MPC specific input parameters:\n\ngrid_draw_limit_kw_by_time_step::Vector{<:Real} limits for grid power consumption in each time step; length must be same as length(loads_kw).\nexport_limit_kw_by_time_step::Vector{<:Real} limits for grid power export in each time step; length must be same as length(loads_kw).\n\nwarn: Warn\ngrid_draw_limit_kw_by_time_step and export_limit_kw_by_time_step values can lead to  infeasible problems. For example, there is a constraint that the electric load must be met in  each time step and by limiting the amount of power from the grid the load balance constraint  could be infeasible.\n\n\n\n\n\n","category":"type"},{"location":"mpc/methods/#Methods","page":"Methods","title":"Methods","text":"","category":"section"},{"location":"mpc/methods/","page":"Methods","title":"Methods","text":"run_mpc\nbuild_mpc!","category":"page"},{"location":"mpc/methods/#REopt.run_mpc","page":"Methods","title":"REopt.run_mpc","text":"run_mpc(m::JuMP.AbstractModel, fp::String)\n\nSolve the model predictive control problem using the MPCScenario defined in the JSON file stored at the file path fp.\n\nReturns a Dict of results with keys matching those in the MPCScenario.\n\n\n\n\n\nrun_mpc(m::JuMP.AbstractModel,  d::Dict)\n\nSolve the model predictive control problem using the MPCScenario defined in the dict d.\n\nReturns a Dict of results with keys matching those in the MPCScenario.\n\n\n\n\n\nrun_mpc(m::JuMP.AbstractModel, p::MPCInputs)\n\nSolve the model predictive control problem using the MPCInputs.\n\nReturns a Dict of results with keys matching those in the MPCScenario.\n\n\n\n\n\n","category":"function"},{"location":"mpc/methods/#REopt.build_mpc!","page":"Methods","title":"REopt.build_mpc!","text":"build_mpc!(m::JuMP.AbstractModel, p::MPCInputs)\n\nAdd variables and constraints for model predictive control model.  Similar to a REopt model but with any length of horizon (instead of one calendar year, and the DER sizes must be provided.\n\n\n\n\n\n","category":"function"},{"location":"developer/adding_tech/#Adding-a-Technology","page":"Adding a Technology","title":"Adding a Technology","text":"","category":"section"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"REopt can be used in many ways, but its primary use is to evaluate the techno-economic feasibility of energy generation and storage technologies. In this section we describe how one might add a new technology to the REopt model for evaluation. At a high level the steps are:","category":"page"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"Define the mathematical model for how the technology will interact with the other technologies, which includes:\ndefining appropriate decision variables (the technology's capacity for example)\ndefining model constraints (operational constraints for example)\nDefine the inputs and default values necessary to model the technology in the mathematical model\nMap the input values to the sets and coefficients needed in the mathematical model\nCreate an adapter function to output the desired results from the mathematical model\nTest the new technology","category":"page"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"All steps are not necessarily executed in this order and in fact most likely must be done in concert. For example, in order to define a model constraint one must define the input parameters. Also, it is good practice to think of how you will test the new technology from the very beginning of the design process and incrementally test your additions to the model as well as make sure that no existing tests fail due to your modifications to REopt.","category":"page"},{"location":"developer/adding_tech/#.-Mathematical-Model","page":"Adding a Technology","title":"1. Mathematical Model","text":"","category":"section"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"Each technology will have unique decision variables and constraints. However, there are some decision variables that apply to many technologies. We will use the PV technology to demonstrate some variables and constraints that are shared among all generation technologies and some that are unique to PV.","category":"page"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"First, the PV technology can meet electrical demand and thus is part of the techs.elec. By including the PV technology in the set of techs.elec we can take advantage of existing model constraints such as the electrical load balance:","category":"page"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"@constraint(m, [ts in p.time_steps_with_grid],\n    sum(p.production_factor[t, ts] * p.levelization_factor[t] * m[Symbol(\"dvRatedProduction\"*_n)][t,ts] for t in p.techs.elec) \n    + sum( m[Symbol(\"dvDischargeFromStorage\"*_n)][b,ts] for b in p.s.storage.types.elec ) \n    + sum(m[Symbol(\"dvGridPurchase\"*_n)][ts, tier] for tier in 1:p.s.electric_tariff.n_energy_tiers) \n    ==\n    sum( sum(m[Symbol(\"dvProductionToStorage\"*_n)][b, t, ts] for b in p.s.storage.types.elec) \n    + m[Symbol(\"dvCurtail\"*_n)][t, ts] for t in p.techs.elec)\n    + sum(m[Symbol(\"dvGridToStorage\"*_n)][b, ts] for b in p.s.storage.types.elec)\n    + p.s.electric_load.loads_kw[ts]\n)","category":"page"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"note: Note\nThroughout the REopt code p is used as the variable name for the concrete instance of REoptInputs. The p is a legacy name from when the REoptInputs was called a parameter structure. Also, m is used throughout the code for the JuMP Model and p.s is the Scenario structure.","category":"page"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"From the load balance constraint we can see that the PV technology (and each techs.elec) includes input parameters for the production_factor and levelization_factor, and that the PV technology has the decision variables dvRatedProduction and dvCurtail.","category":"page"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"note: Note\nAll decision variables in the model start with dv and use camel case naming after dv. Also, in order to take advantage of dynamic variable names for multinode models we use the Symbol notation (e.g. m[Symbol(\"dvProductionToStorage\"*_n)) to define and access variables in the model.","category":"page"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"The p.techs data structure is defined as follows:","category":"page"},{"location":"developer/adding_tech/#Techs","page":"Adding a Technology","title":"Techs","text":"","category":"section"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"REopt.Techs\nREopt.Techs(s::Scenario)\nREopt.Techs(p::REoptInputs, s::BAUScenario)","category":"page"},{"location":"developer/adding_tech/#REopt.Techs","page":"Adding a Technology","title":"REopt.Techs","text":"Techs\n\nTechs contains the index sets that are used to define the model constraints and decision variables.\n\nmutable struct Techs\n    all::Vector{String}\n    elec::Vector{String}\n    pv::Vector{String}\n    gen::Vector{String}\n    pbi::Vector{String}\n    no_curtail::Vector{String}\n    no_turndown::Vector{String}\n    segmented::Vector{String}\n    heating::Vector{String}\n    boiler::Vector{String}\n    fuel_burning::Vector{String}\n    thermal::Vector{String}\n    chp::Vector{String}\n    electric_chiller::Vector{String}\n    absorption_chiller::Vector{String}\nend\n\n\n\n\n\n","category":"type"},{"location":"developer/adding_tech/#REopt.Techs-Tuple{Scenario}","page":"Adding a Technology","title":"REopt.Techs","text":"Techs(s::Scenario)\n\nCreate a Techs struct for the REoptInputs.\n\n\n\n\n\n","category":"method"},{"location":"developer/adding_tech/#REopt.Techs-Tuple{REoptInputs, BAUScenario}","page":"Adding a Technology","title":"REopt.Techs","text":"Techs(p::REoptInputs, s::BAUScenario)\n\nCreate a Techs struct for the BAUInputs\n\n\n\n\n\n","category":"method"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"From the Techs definition we can see that there are already a lot of different energy generation technology categories in REopt. Adding a new technology to the model could be as simple as adding the appropriate inputs to REoptInputs (described in the next section) and using the Techs structure to define which variables and constraints apply to the new technology.","category":"page"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"The PV technology is also part of a unique set of Techs, namely the techs.pv (there can be multiple PV technologies in a single model as we will see soon). An example of a constraint applied over techs.pv is:","category":"page"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"@constraint(m, [loc in p.pvlocations],\n    sum(m[Symbol(\"dvSize\"*_n)][t] * p.pv_to_location[t][loc] for t in p.techs.pv) <= p.maxsize_pv_locations[loc]\n)","category":"page"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"Here we can see that the dvSize for each techs.pv is constrained based on the location of each PV technology. This constraint allows us to uniquely limit the PV capacity for roof mounted systems vs. ground mounted systems based on the available space at a site. We also see some additional inputs for the PV technology, such as the pvlocations and maxsize_pv_locations. Creating these input values is described in the next two sections.","category":"page"},{"location":"developer/adding_tech/#.-User-Inputs","page":"Adding a Technology","title":"2. User Inputs","text":"","category":"section"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"Any new technology should have a technologyname.jl file in the src/core directory. For example, in the src/core/pv.jl file we have a data structure and constructor for defining default values and creating the PV structure that is attached to the Scenario. Once the new technology's data structure is defined it must be added to the Scenario structure (see src/core/scenario.jl). ","category":"page"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"When adding a new technology to REopt one must decide on how a user of the REopt will define the technology. Continuing with the PV example we saw that we need to define the production_factor for the PV technology in every time step. The production_factor varies from zero to one and defines the availability of the technology. For PV we have a default method for creating the production_factor as well as allow the user to provide their own production_factor.","category":"page"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"We let the user define the production_factor by providing the PVs prod_factor_series input in their JSON file or dictionary when creating their Scenario. If the user does not provide a value for prod_factor_series then we use the PVWatts API to get a production_factor based on the Site.latitude and Site.longitude. The PV inputs structure also allows the user to change the arguments that are passed to PVWatts.","category":"page"},{"location":"developer/adding_tech/#.-REopt-Inputs","page":"Adding a Technology","title":"3. REopt Inputs","text":"","category":"section"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"The REoptInputs constructor is the work-horse for defining all the mathematical model parameters. It converts the user's Scenario into a format that is necessary for adding the model decision variables and constraints.","category":"page"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"A major part of the REoptInputs constructor is creating arrays that are indexed on sets of strings (defined in Techs) that allow us to define constraints all applicable technologies. Continuing with the PV example, the electrical load balance constraint includes:","category":"page"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"sum(p.production_factor[t, ts] * p.levelization_factor[t] * m[Symbol(\"dvRatedProduction\"*_n)][t,ts] for t in p.techs.elec) ","category":"page"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"which implies that we need to define a production_factor for all techs.elec in every time step ts. To create the production_factor array the REoptInputs constructor first creates an empty array like so:","category":"page"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"production_factor = DenseAxisArray{Float64}(undef, techs.all, 1:length(s.electric_load.loads_kw))","category":"page"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"and then passes that array to technology specific functions that add their production factors to the production_factor array. For example, for PV within the setup_pv_inputs method we have:","category":"page"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"for pv in s.pvs\n    production_factor[pv.name, :] = prodfactor(pv, s.site.latitude, s.site.longitude)\n    ...\nend","category":"page"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"The completed production_factor array is then attached to the REoptInputs structure so that it can be used as needed to create the mathematical model.","category":"page"},{"location":"developer/adding_tech/#.-Results","page":"Adding a Technology","title":"4. Results","text":"","category":"section"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"After adding a new technology to the REopt mathematical model and getting the new inputs set up you can create some results from the optimized model. Some or all of your new results can also be used in a test for the new technology.","category":"page"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"All of the results methods are defined in src/results, with src/results/results.jl containing the main method for creating results. The results are returned to the user as a dictionary. If a user is not modeling your new technology then there is no reason to create any new results. Therefore, in reopt_results we have:","category":"page"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"if !isempty(p.techs.pv)\n    add_pv_results(m, p, d; _n)\nend","category":"page"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"which uses the model m and the REoptInputs p to add results to the dictionary d.","category":"page"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"note: Note\nThe _n argument is used in many places in REopt to optionally modeled multinode scenarios. The default value for _n is an empty string. When modeling multiple nodes the n in the _n string is set to the Site.node value, which is an integer. For example, if the Site.node is 3 then _n = \"_3\".","category":"page"},{"location":"developer/adding_tech/#.-Testing-the-new-technology","page":"Adding a Technology","title":"5. Testing the new technology","text":"","category":"section"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"Adding a new test is not necessarily the last step in adding a technology to the REopt model. In fact, it is best to use a simple test to test your code as you add the new technolgy and then adapt the test as you add more capability to the code. For example, once you have created you new technology's input interface you can test just creating a Scenario with the new technology by passing the path to a JSON file that contains the minimum required inputs for a Scenario and your new technology. This might look like:","category":"page"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"@testset \"My new technology\" begin\n    s = Scenario(\"path/to/mynewtech.json\")\nend","category":"page"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"The next testing step might be checking the REoptInputs additions for your new technolgy:","category":"page"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"@testset \"My new technology\" begin\n    s = Scenario(\"path/to/mynewtech.json\")\n    p = REoptInputs(s)\nend","category":"page"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"Once you have all of your new inputs set up you can test the model creation with:","category":"page"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"@testset \"My new technology\" begin\n    m = Model(Cbc.Optimizer)\n    build_reopt!(m, \"path/to/mynewtech.json\")\nend","category":"page"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"Finally, you can test the full work-flow with something like:","category":"page"},{"location":"developer/adding_tech/","page":"Adding a Technology","title":"Adding a Technology","text":"@testset \"My new technology\" begin\n    m = Model(Cbc.Optimizer)\n    results = run_reopt(m, \"path/to/mynewtech.json\")\n    @test results[\"mynewtech\"][\"some_result\"]  78.9 atol=0.1\nend","category":"page"},{"location":"developer/inputs/#The-REoptInputs-structure","page":"The REoptInputs structure","title":"The REoptInputs structure","text":"","category":"section"},{"location":"developer/inputs/","page":"The REoptInputs structure","title":"The REoptInputs structure","text":"The REoptInputs structure uses the Scenario to build all of the data necessary to construct the JuMP mathematical model.","category":"page"},{"location":"developer/inputs/#REoptInputs","page":"The REoptInputs structure","title":"REoptInputs","text":"","category":"section"},{"location":"developer/inputs/","page":"The REoptInputs structure","title":"The REoptInputs structure","text":"REoptInputs\nREoptInputs(fp::String)\nREoptInputs(s::REopt.AbstractScenario)","category":"page"},{"location":"developer/inputs/#REopt.REoptInputs","page":"The REoptInputs structure","title":"REopt.REoptInputs","text":"REoptInputs\n\nThe data structure for all the inputs necessary to construct the JuMP model.\n\nstruct REoptInputs <: AbstractInputs\n    s::AbstractScenario\n    techs::Techs\n    storage::Storage\n    min_sizes::Dict{String, Float64}  # (techs)\n    max_sizes::Dict{String, Float64}  # (techs)\n    existing_sizes::Dict{String, Float64}  # (techs)\n    cap_cost_slope::Dict{String, Any}  # (techs)\n    om_cost_per_kw::Dict{String, Float64}  # (techs)\n    time_steps::UnitRange\n    time_steps_with_grid::Array{Int, 1}\n    time_steps_without_grid::Array{Int, 1}\n    hours_per_timestep::Float64\n    months::UnitRange\n    production_factor::DenseAxisArray{Float64, 2}  # (techs, time_steps)\n    levelization_factor::Dict{String, Float64}  # (techs)\n    value_of_lost_load_per_kwh::Array{R, 1} where R<:Real #default set to 1 US dollar per kwh\n    pwf_e::Float64\n    pwf_om::Float64\n    third_party_factor::Float64\n    pvlocations::Array{Symbol, 1}\n    maxsize_pv_locations::DenseAxisArray{Float64, 1}  # indexed on pvlocations\n    pv_to_location::Dict{String, Dict{Symbol, Int64}}  # (techs.pv, pvlocations)\n    ratchets::UnitRange\n    techs_by_exportbin::Dict{Symbol, AbstractArray}  # keys can include [:NEM, :WHL, :CUR]\n    export_bins_by_tech::Dict\n    n_segs_by_tech::Dict{String, Int}\n    seg_min_size::Dict{String, Dict{Int, Float64}}\n    seg_max_size::Dict{String, Dict{Int, Float64}}\n    seg_yint::Dict{String, Dict{Int, Float64}}\n    pbi_pwf::Dict{String, Any}  # (pbi_techs)\n    pbi_max_benefit::Dict{String, Any}  # (pbi_techs)\n    pbi_max_kw::Dict{String, Any}  # (pbi_techs)\n    pbi_benefit_per_kwh::Dict{String, Any}  # (pbi_techs)\n    boiler_efficiency::Dict{String, Float64}\nend\n\n\n\n\n\n","category":"type"},{"location":"developer/inputs/#REopt.REoptInputs-Tuple{String}","page":"The REoptInputs structure","title":"REopt.REoptInputs","text":"REoptInputs(fp::String)\n\nUse fp to load in JSON scenario:\n\nfunction REoptInputs(fp::String)\n    s = Scenario(JSON.parsefile(fp))\n    REoptInputs(s)\nend\n\nUseful if you want to manually modify REoptInputs before solving the model.\n\n\n\n\n\n","category":"method"},{"location":"developer/inputs/#REopt.REoptInputs-Tuple{REopt.AbstractScenario}","page":"The REoptInputs structure","title":"REopt.REoptInputs","text":"REoptInputs(s::AbstractScenario)\n\nConstructor for REoptInputs. Translates the Scenario into all the data necessary for building the JuMP model.\n\n\n\n\n\n","category":"method"},{"location":"developer/inputs/#Design-Concepts-for-REoptInputs","page":"The REoptInputs structure","title":"Design Concepts for REoptInputs","text":"","category":"section"},{"location":"developer/inputs/","page":"The REoptInputs structure","title":"The REoptInputs structure","text":"At a high level the REoptInputs constructor does the following tasks:","category":"page"},{"location":"developer/inputs/","page":"The REoptInputs structure","title":"The REoptInputs structure","text":"build index sets for the JuMP model decision variables,\ncreate maps from one set to another set,\nand generate coefficient arrays necessary for model constraints.","category":"page"},{"location":"developer/inputs/#Index-Sets","page":"The REoptInputs structure","title":"Index Sets","text":"","category":"section"},{"location":"developer/inputs/","page":"The REoptInputs structure","title":"The REoptInputs structure","text":"There are a few String[] that are built by REoptInputs that are then used as index sets in the model constraints. The primary index set is the techs.all array of strings, which contains all the technolgy names that are being modeled. With the techs.all array we can easily apply a constraint over all technolgies. For example:","category":"page"},{"location":"developer/inputs/","page":"The REoptInputs structure","title":"The REoptInputs structure","text":"@constraint(m, [t in p.techs.all],\n    m[Symbol(\"dvSize\"*_n)][t] <= p.max_sizes[t]\n)","category":"page"},{"location":"developer/inputs/","page":"The REoptInputs structure","title":"The REoptInputs structure","text":"where p is the REoptInputs struct. There are a couple things to note from this last example:","category":"page"},{"location":"developer/inputs/","page":"The REoptInputs structure","title":"The REoptInputs structure","text":"The decision variable dvSize is accessed in the JuMP.Model m using the Symbol notation so that this constraint can be used in the multi-node case in addition to the single node case. The _n input value is an empty string by default and in the case of a multi-node model the _n string will be set by the Site.node integer. For example, if Site.node is 3 then _n is \"_3\".\nThe p.max_sizes array is also indexed on p.techs.all. The max_sizes is built in the REoptInputs constructor by using all the technologies in the Scenario that have max_kw values greater than zero.","category":"page"},{"location":"developer/inputs/","page":"The REoptInputs structure","title":"The REoptInputs structure","text":"Besides the techs.all array the are many sub-sets, such as techs.pv, techs.gen, techs.elec, p.techs.segmented, techs.no_curtail, that allow us to apply constraints to those sets. For example:","category":"page"},{"location":"developer/inputs/","page":"The REoptInputs structure","title":"The REoptInputs structure","text":"for t in p.techs.no_curtail\n    for ts in p.time_steps\n        fix(m[Symbol(\"dvCurtail\"*_n)][t, ts] , 0.0, force=true)\n    end\nend","category":"page"},{"location":"developer/inputs/#Set-maps","page":"The REoptInputs structure","title":"Set maps","text":"","category":"section"},{"location":"developer/inputs/","page":"The REoptInputs structure","title":"The REoptInputs structure","text":"The set maps are best explained with an example. The techs_by_exportbin map uses each technology'sattributes (eg. PV) to map each technology to which export bins that technology can access. The export bins include:","category":"page"},{"location":"developer/inputs/","page":"The REoptInputs structure","title":"The REoptInputs structure","text":":NEM (Net Energy Metering)\n:WHL (Wholesale)\n:EXC (Excess, beyond NEM))","category":"page"},{"location":"developer/inputs/","page":"The REoptInputs structure","title":"The REoptInputs structure","text":"The bins that a technolgy can access are determined by the technologies attributes can_net_meter, can_wholesale, and can_export_beyond_nem_limit. So if PV.can_net_meter = true, Wind.can_net_meter = true and all the other attributes are false then the techs_by_exportbin will only have one non-empty key:","category":"page"},{"location":"developer/inputs/","page":"The REoptInputs structure","title":"The REoptInputs structure","text":"techs_by_exportbin = Dict(\n    :NEM => [\"PV\", \"Wind\"],\n    :WHL => [],\n    :EXC => []\n)","category":"page"},{"location":"developer/inputs/","page":"The REoptInputs structure","title":"The REoptInputs structure","text":"A use-case example for the techs_by_exportbin map is defining the net metering benefit:","category":"page"},{"location":"developer/inputs/","page":"The REoptInputs structure","title":"The REoptInputs structure","text":"NEM_benefit = @expression(m, p.pwf_e * p.hours_per_timestep *\n    sum( sum(p.s.electric_tariff.export_rates[:NEM][ts] * m[Symbol(\"dvProductionToGrid\"*_n)][t, :NEM, ts] \n        for t in p.techs_by_exportbin[:NEM]) for ts in p.time_steps)\n)","category":"page"},{"location":"developer/inputs/","page":"The REoptInputs structure","title":"The REoptInputs structure","text":"Other set maps include: export_bins_by_tech and n_segs_by_tech. The latter tells how many cost curve segments each technology has.","category":"page"},{"location":"developer/inputs/#Coefficient-Arrays","page":"The REoptInputs structure","title":"Coefficient Arrays","text":"","category":"section"},{"location":"developer/inputs/","page":"The REoptInputs structure","title":"The REoptInputs structure","text":"The JuMP model costs are formulated in net present value terms, accounting for all benefits (production, capacity, and investment incentives) and the total cost over the analysis_period. The REoptInputs constructor translates the raw input parameters, such as the operations and maintenance costs, into present value terms using the provided discount rate. For example, the pwf_e is the present worth factor for electricity that accounts for the elec_cost_escalation_pct, the analysis_period, and the offtaker_discount_pct. Note that tax benefits are applied directly in the JuMP model for clarity on which costs are tax-deductible and which are not.","category":"page"},{"location":"developer/inputs/","page":"The REoptInputs structure","title":"The REoptInputs structure","text":"Besides econimic parameters, the REoptInputs constructor also puts together the important production_factor array. The production_factor array is simple for continuously variable generators (such as the Generator), for which the production_factor is 1 in all time steps. However, for variable generators (such as Wind and PV) the production_factor varies by time step. If the user does not provide the PV production factor, for example, then the REoptInputs constructor uses the PVWatts API to download the location specific PV production factor. REoptInputs also accounts for the PV.degradation_pct in building the production_factor array.","category":"page"},{"location":"reopt/methods/#Methods","page":"Methods","title":"Methods","text":"","category":"section"},{"location":"reopt/methods/","page":"Methods","title":"Methods","text":"The primary method for using REopt is the run_reopt method. In the simplest there are two required inputs to run_reopt: a JuMP.Model with an optimizer and the path to a JSON file to define the Scenario. Other methods for run_reopt are enumerated below. Other methods such as build_reopt! are also described to allow users to build custom REopt models. For example, after using build_reopt! a user could add constraints or change the objective function using JuMP commands.","category":"page"},{"location":"reopt/methods/#run_reopt","page":"Methods","title":"run_reopt","text":"","category":"section"},{"location":"reopt/methods/","page":"Methods","title":"Methods","text":"run_reopt","category":"page"},{"location":"reopt/methods/#REopt.run_reopt","page":"Methods","title":"REopt.run_reopt","text":"run_reopt(m::JuMP.AbstractModel, fp::String)\n\nSolve the model using the Scenario defined in JSON file stored at the file path fp.\n\n\n\n\n\nrun_reopt(m::JuMP.AbstractModel, d::Dict)\n\nSolve the model using the Scenario defined in dict d.\n\n\n\n\n\nrun_reopt(m::JuMP.AbstractModel, s::AbstractScenario)\n\nSolve the model using a Scenario or BAUScenario.\n\n\n\n\n\nrun_reopt(t::Tuple{JuMP.AbstractModel, AbstractScenario})\n\nMethod for use with Threads when running BAU in parallel with optimal scenario.\n\n\n\n\n\nrun_reopt(ms::AbstractArray{T, 1}, fp::String) where T <: JuMP.AbstractModel\n\nSolve the Scenario and BAUScenario in parallel using the first two (empty) models in ms and inputs defined in the JSON file at the filepath fp.\n\n\n\n\n\nrun_reopt(ms::AbstractArray{T, 1}, d::Dict) where T <: JuMP.AbstractModel\n\nSolve the Scenario and BAUScenario in parallel using the first two (empty) models in ms and inputs from d.\n\n\n\n\n\nrun_reopt(ms::AbstractArray{T, 1}, p::REoptInputs) where T <: JuMP.AbstractModel\n\nSolve the Scenario and BAUScenario in parallel using the first two (empty) models in ms and inputs from p.\n\n\n\n\n\n","category":"function"},{"location":"reopt/methods/#build_reopt!","page":"Methods","title":"build_reopt!","text":"","category":"section"},{"location":"reopt/methods/","page":"Methods","title":"Methods","text":"build_reopt!","category":"page"},{"location":"reopt/methods/#REopt.build_reopt!","page":"Methods","title":"REopt.build_reopt!","text":"build_reopt!(m::JuMP.AbstractModel, fp::String)\n\nAdd variables and constraints for REopt model.  fp is used to load in JSON file to construct REoptInputs.\n\n\n\n\n\nbuild_reopt!(m::JuMP.AbstractModel, p::REoptInputs)\n\nAdd variables and constraints for REopt model.\n\n\n\n\n\n","category":"function"},{"location":"reopt/methods/#simulate_outages","page":"Methods","title":"simulate_outages","text":"","category":"section"},{"location":"reopt/methods/","page":"Methods","title":"Methods","text":"simulate_outages","category":"page"},{"location":"reopt/methods/#REopt.simulate_outages","page":"Methods","title":"REopt.simulate_outages","text":"simulate_outages(;batt_kwh=0, batt_kw=0, pv_kw_ac_hourly=[], init_soc=[], critical_loads_kw=[], \n    wind_kw_ac_hourly=[], batt_roundtrip_efficiency=0.829, diesel_kw=0, fuel_available=0, b=0, m=0, \n    diesel_min_turndown=0.3\n)\n\nTime series simulation of outages starting at every time step of the year. Used to calculate how many time steps the  critical load can be met in every outage, which in turn is used to determine probabilities of meeting the critical load.\n\nArguments\n\nbatt_kwh: float, battery storage capacity\nbatt_kw: float, battery inverter capacity\npv_kw_ac_hourly: list of floats, AC production of PV system\ninit_soc: list of floats between 0 and 1 inclusive, initial state-of-charge\ncritical_loads_kw: list of floats\nwind_kw_ac_hourly: list of floats, AC production of wind turbine\nbatt_roundtrip_efficiency: roundtrip battery efficiency\ndiesel_kw: float, diesel generator capacity\nfuel_available: float, gallons of diesel fuel available\nb: float, diesel fuel burn rate intercept coefficient (y = mx + brated_capacity)  [gal/kwh/kw]\nm: float, diesel fuel burn rate slope (y = mx + brated_capacity)  [gal/kWh]\ndiesel_min_turndown: minimum generator turndown in fraction of generator capacity (0 to 1)\n\nReturns a dict\n\n    \"resilience_by_timestep\": vector of time steps that critical load is met for outage starting in every time step,\n    \"resilience_hours_min\": minimum of \"resilience_by_timestep\",\n    \"resilience_hours_max\": maximum of \"resilience_by_timestep\",\n    \"resilience_hours_avg\": average of \"resilience_by_timestep\",\n    \"outage_durations\": vector of integers for outage durations with non zero probability of survival,\n    \"probs_of_surviving\": vector of probabilities corresponding to the \"outage_durations\",\n    \"probs_of_surviving_by_month\": vector of probabilities calculated on a monthly basis,\n    \"probs_of_surviving_by_hour_of_the_day\":vector of probabilities calculated on a hour-of-the-day basis,\n}\n\n\n\n\n\nsimulate_outages(d::Dict, p::REoptInputs; microgrid_only::Bool=false)\n\nTime series simulation of outages starting at every time step of the year. Used to calculate how many time steps the  critical load can be met in every outage, which in turn is used to determine probabilities of meeting the critical load.\n\nArguments\n\nd::Dict from reopt_results\np::REoptInputs the inputs that generated the Dict from reopt_results\nmicrogrid_only::Bool whether or not to simulate only the optimal microgrid capacities or the total capacities. This input is only relevant when modeling multiple outages.\n\nReturns a dict\n\n{\n    \"resilience_by_timestep\": vector of time steps that critical load is met for outage starting in every time step,\n    \"resilience_hours_min\": minimum of \"resilience_by_timestep\",\n    \"resilience_hours_max\": maximum of \"resilience_by_timestep\",\n    \"resilience_hours_avg\": average of \"resilience_by_timestep\",\n    \"outage_durations\": vector of integers for outage durations with non zero probability of survival,\n    \"probs_of_surviving\": vector of probabilities corresponding to the \"outage_durations\",\n    \"probs_of_surviving_by_month\": vector of probabilities calculated on a monthly basis,\n    \"probs_of_surviving_by_hour_of_the_day\":vector of probabilities calculated on a hour-of-the-day basis,\n}\n\n\n\n\n\n","category":"function"},{"location":"reopt/examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"reopt/examples/","page":"Examples","title":"Examples","text":"To use REopt you will need to have a solver installed. REopt.jl has been tested with Xpress, Cbc, and CPLEX solvers, but it should work with other Linear Progam solvers (for PV and Storage scenarios) or Mixed Integer Linear Program solvers (for scenarios with outages and/or Generators).","category":"page"},{"location":"reopt/examples/#Basic","page":"Examples","title":"Basic","text":"","category":"section"},{"location":"reopt/examples/","page":"Examples","title":"Examples","text":"using REopt, JuMP, Cbc\n\nm = Model(Cbc.Optimizer)\nresults = run_reopt(m, \"test/scenarios/pv_storage.json\")","category":"page"},{"location":"reopt/examples/","page":"Examples","title":"Examples","text":"See pv_storage.json for details on the Scenario.","category":"page"},{"location":"reopt/examples/","page":"Examples","title":"Examples","text":"For more on the scenario.json see the REopt Inputs section.","category":"page"},{"location":"reopt/examples/","page":"Examples","title":"Examples","text":"In order to calculate additional result metrics you can run the BAUScenario scenario in parallel by providing two JuMP.Models like so:","category":"page"},{"location":"reopt/examples/","page":"Examples","title":"Examples","text":"m1 = Model(Cbc.Optimizer)\nm2 = Model(Cbc.Optimizer)\nresults = run_reopt([m1,m2], \"./scenarios/pv_storage.json\")","category":"page"},{"location":"reopt/examples/","page":"Examples","title":"Examples","text":"With the BAUScenario results we can calculate the net present value of the optimal system.","category":"page"},{"location":"reopt/examples/","page":"Examples","title":"Examples","text":"note: Note\nThe Settings.run_bau is true by default and so there is no need to change the run_bau value in general since it is ignored when only one JuMP.Model is passed to the run_reopt method. We include the run_bau option to align with the REopt API Settings.","category":"page"},{"location":"reopt/examples/#Advanced","page":"Examples","title":"Advanced","text":"","category":"section"},{"location":"reopt/examples/#Modifying-the-mathematical-model","page":"Examples","title":"Modifying the mathematical model","text":"","category":"section"},{"location":"reopt/examples/","page":"Examples","title":"Examples","text":"Using the build_reopt! method and JuMP methods one can modify the REopt model before optimizing. In the following example we add a cost for curtailed PV power.","category":"page"},{"location":"reopt/examples/","page":"Examples","title":"Examples","text":"using Xpress\nusing JuMP\nusing REopt\n\nm = JuMP.Model(Xpress.Optimizer)\n\np = REoptInputs(\"scenarios/pv_storage.json\");\n\nbuild_reopt!(m, p)\n\n#= \nreplace the original objective, which is to Min the Costs,\nwith the Costs + 100 * (total curtailed PV power)\n=#  \nJuMP.@objective(m, Min, m[:Costs] + 100 * sum(m[:dvCurtail][\"PV\", ts] for ts in p.time_steps));\n\nJuMP.optimize!(m)  # normally this command is called in run_reopt\n\nresults = reopt_results(m, p)","category":"page"},{"location":"reopt/examples/","page":"Examples","title":"Examples","text":"One can also add variables and constraints to the model before optimizing using the JuMP commands.","category":"page"},{"location":"reopt/examples/","page":"Examples","title":"Examples","text":"note: Note\nThe JuMP. prefixes are not necessary. We include them in the example to show which commands come from JuMP.","category":"page"},{"location":"reopt/inputs/#REopt-Inputs","page":"REopt Inputs","title":"REopt Inputs","text":"","category":"section"},{"location":"reopt/inputs/","page":"REopt Inputs","title":"REopt Inputs","text":"Inputs to run_reopt can be provided in one of three formats:","category":"page"},{"location":"reopt/inputs/","page":"REopt Inputs","title":"REopt Inputs","text":"a file path (string) to a JSON file,\na Dict, or\nusing the REoptInputs struct","category":"page"},{"location":"reopt/inputs/","page":"REopt Inputs","title":"REopt Inputs","text":"Any one of these types can be passed to the run_reopt method.","category":"page"},{"location":"reopt/inputs/","page":"REopt Inputs","title":"REopt Inputs","text":"The first option is perhaps the most straightforward one. For example, the minimum requirements for a JSON scenario file would look like:","category":"page"},{"location":"reopt/inputs/","page":"REopt Inputs","title":"REopt Inputs","text":"{\n    \"Site\": {\n        \"longitude\": -118.1164613,\n        \"latitude\": 34.5794343\n    },\n    \"ElectricLoad\": {\n        \"doe_reference_name\": \"MidriseApartment\",\n        \"annual_kwh\": 1000000.0\n    },\n    \"ElectricTariff\": {\n        \"urdb_label\": \"5ed6c1a15457a3367add15ae\"\n    }\n}","category":"page"},{"location":"reopt/inputs/","page":"REopt Inputs","title":"REopt Inputs","text":"The order of the keys do not matter. Note that this scenario does not include any energy generation technologies and therefore the results can be used as a baseline for comparison to scenarios that result in cost-optimal generation technologies.","category":"page"},{"location":"reopt/inputs/","page":"REopt Inputs","title":"REopt Inputs","text":"To add PV to the analysis simply add a PV key with an empty dictionary (to use default values):","category":"page"},{"location":"reopt/inputs/","page":"REopt Inputs","title":"REopt Inputs","text":"{\n    \"Site\": {\n        \"longitude\": -118.1164613,\n        \"latitude\": 34.5794343\n    },\n    \"ElectricLoad\": {\n        \"doe_reference_name\": \"MidriseApartment\",\n        \"annual_kwh\": 1000000.0\n    },\n    \"ElectricTariff\": {\n        \"urdb_label\": \"5ed6c1a15457a3367add15ae\"\n    },\n    \"PV\": {}\n}","category":"page"},{"location":"reopt/inputs/","page":"REopt Inputs","title":"REopt Inputs","text":"This scenario will consider the option to purchase a solar PV system to reduce energy costs, and if solar PV can reduce the energy costs then REopt will provide the optimal PV capacity (assuming perfect foresight!). To use other than default values for PV see the PV struct definition.  For example, the site under consideration might have some existing PV capacity to account for, which can be done by setting the existing_kw key to the appropriate value.","category":"page"},{"location":"reopt/inputs/#Scenario","page":"REopt Inputs","title":"Scenario","text":"","category":"section"},{"location":"reopt/inputs/","page":"REopt Inputs","title":"REopt Inputs","text":"The Scenario struct captures all of the objects that can be included in a scenario.json:","category":"page"},{"location":"reopt/inputs/","page":"REopt Inputs","title":"REopt Inputs","text":"Scenario","category":"page"},{"location":"reopt/inputs/#REopt.Scenario","page":"REopt Inputs","title":"REopt.Scenario","text":"Scenario(d::Dict; flex_hvac_from_json=false)\n\nConstructor for Scenario struct, where d has upper-case keys:\n\nSite (required)\nElectricTariff (required)\nElectricLoad (required)\nPV (optional, can be Array)\nWind (optional)\nElectricStorage (optional)\nElectricUtility (optional)\nFinancial (optional)\nGenerator (optional)\nDomesticHotWaterLoad (optional)\nSpaceHeatingLoad (optional)\nExistingBoiler (optional)\nCHP (optional)\nFlexibleHVAC (optional)\nExistingChiller (optional)\nAbsorptionChiller (optional)\n\nAll values of d are expected to be Dicts except for PV, which can be either a Dict or Dict[].\n\nSet flex_hvac_from_json=true if FlexibleHVAC values were loaded in from JSON (necessary to  handle conversion of Vector of Vectors from JSON to a Matrix in Julia).\n\n\n\n\n\nScenario(fp::String)\n\nConsruct Scenario from filepath fp to JSON with keys aligned with the Scenario(d::Dict) method.\n\n\n\n\n\n","category":"type"},{"location":"reopt/inputs/#BAUScenario","page":"REopt Inputs","title":"BAUScenario","text":"","category":"section"},{"location":"reopt/inputs/","page":"REopt Inputs","title":"REopt Inputs","text":"The BAUScenario struct is for running Business-As-Usual scenarios, i.e. without any new technologies. The results of the BAU scenario are used to calculate other Financial results such as the net present value.","category":"page"},{"location":"reopt/inputs/","page":"REopt Inputs","title":"REopt Inputs","text":"BAUScenario","category":"page"},{"location":"reopt/inputs/#REopt.BAUScenario","page":"REopt Inputs","title":"REopt.BAUScenario","text":"BAUScenario(s::Scenario)\n\nConstructor for BAUScenario (BAU = Business As Usual) struct.\n\nsets the PV and Generator maxkw values to the existingkw values\nsets wind and storage max_kw values to zero\n\n\n\n\n\n","category":"type"},{"location":"reopt/inputs/#Site","page":"REopt Inputs","title":"Site","text":"","category":"section"},{"location":"reopt/inputs/","page":"REopt Inputs","title":"REopt Inputs","text":"REopt.Site","category":"page"},{"location":"reopt/inputs/#REopt.Site","page":"REopt Inputs","title":"REopt.Site","text":"Site\n\nInputs related to the physical location:\n\nfunction Site(;\n    latitude::Real, \n    longitude::Real, \n    land_acres::Union{Float64, Nothing} = nothing, \n    roof_squarefeet::Union{Float64, Nothing} = nothing,\n    min_resil_timesteps::Int=0,\n    mg_tech_sizes_equal_grid_sizes::Bool = true,\n    node::Int = 1, \n    )\n\n\n\n\n\n","category":"type"},{"location":"reopt/inputs/#ElectricLoad","page":"REopt Inputs","title":"ElectricLoad","text":"","category":"section"},{"location":"reopt/inputs/","page":"REopt Inputs","title":"REopt Inputs","text":"REopt.ElectricLoad","category":"page"},{"location":"reopt/inputs/#REopt.ElectricLoad","page":"REopt Inputs","title":"REopt.ElectricLoad","text":"ElectricLoad(;\n    loads_kw::Array{<:Real,1} = Real[],\n    path_to_csv::String = \"\",\n    year::Int = 2020,\n    doe_reference_name::String = \"\",\n    blended_doe_reference_names::Array{String, 1} = String[],\n    blended_doe_reference_percents::Array{<:Real,1} = Real[],\n    city::String = \"\",\n    annual_kwh::Union{Real, Nothing} = nothing,\n    monthly_totals_kwh::Array{<:Real,1} = Real[],\n    critical_loads_kw::Union{Missing, Array{Real,1}} = missing,\n    loads_kw_is_net::Bool = true,\n    critical_loads_kw_is_net::Bool = false,\n    critical_load_pct::Real = 0.5,\n    time_steps_per_hour::Int = 1\n)\n\nMust provide either loads_kw or path_to_csv or [doe_reference_name and city] or doe_reference_name or [blended_doe_reference_names and blended_doe_reference_percents]. \n\nWhen only doe_reference_name is provided the Site.latitude and Site.longitude are used to look up the ASHRAE climate zone, which determines the appropriate DoE Commercial Reference Building profile.\n\nWhen using the [doe_reference_name and city] option, choose city from one of the  cities used to represent the ASHRAE climate zones:\n\nAlbuquerque\nAtlanta\nBaltimore\nBoulder\nChicago\nDuluth\nFairbanks\nHelena\nHouston\nLosAngeles\nMiami\nMinneapolis\nPhoenix\nSanFrancisco\nSeattle\n\nand doe_reference_name from:\n\nFastFoodRest\nFullServiceRest\nHospital\nLargeHotel\nLargeOffice\nMediumOffice\nMidriseApartment\nOutpatient\nPrimarySchool\nRetailStore\nSecondarySchool\nSmallHotel\nSmallOffice\nStripMall\nSupermarket\nWarehouse\nFlatLoad\n\nEach city and doe_reference_name combination has a default annual_kwh, or you can provide your own annual_kwh or monthly_totals_kwh and the reference profile will be scaled appropriately.\n\n\n\n\n\n","category":"type"},{"location":"reopt/inputs/#ElectricTariff","page":"REopt Inputs","title":"ElectricTariff","text":"","category":"section"},{"location":"reopt/inputs/","page":"REopt Inputs","title":"REopt Inputs","text":"REopt.ElectricTariff\nREopt.ElectricTariff()","category":"page"},{"location":"reopt/inputs/#REopt.ElectricTariff","page":"REopt Inputs","title":"REopt.ElectricTariff","text":"struct ElectricTariff\n\ndata for electric tariff in reopt model\ncan be defined using custom rates or URDB rate\nvery similar to the URDB struct but includes export rates and bins\n\n\n\n\n\n","category":"type"},{"location":"reopt/inputs/#REopt.ElectricTariff-Tuple{}","page":"REopt Inputs","title":"REopt.ElectricTariff","text":"ElectricTariff\n\nElectricTariff constructor\n\nfunction ElectricTariff(;\n    urdb_label::String=\"\",\n    urdb_response::Dict=Dict(),\n    urdb_utility_name::String=\"\",\n    urdb_rate_name::String=\"\",\n    year::Int=2020,\n    time_steps_per_hour::Int=1,\n    NEM::Bool=false,\n    wholesale_rate::T1=nothing,\n    export_rate_beyond_net_metering_limit::T2=nothing,\n    monthly_energy_rates::Array=[],\n    monthly_demand_rates::Array=[],\n    blended_annual_energy_rate::S=nothing,\n    blended_annual_demand_rate::R=nothing,\n    add_monthly_rates_to_urdb_rate::Bool=false,\n    tou_energy_rates_per_kwh::Array=[],\n    add_tou_energy_rates_to_urdb_rate::Bool=false,\n    remove_tiers::Bool=false,\n    demand_lookback_months::AbstractArray{Int64, 1}=Int64[],\n    demand_lookback_percent::Float64=0.0,\n    demand_lookback_range::Int=0,\n    coincident_peak_load_active_timesteps::Vector{Vector{Int64}}=[Int64[]],\n    coincident_peak_load_charge_per_kw::AbstractVector{<:Real}=Real[]\n    ) where {\n        T1 <: Union{Nothing, Int, Float64, Array}, \n        T2 <: Union{Nothing, Int, Float64, Array}, \n        S <: Union{Nothing, Int, Float64}, \n        R <: Union{Nothing, Int, Float64}\n    }\n\nnote: Note\nThe NEM boolean is determined by the ElectricUtility.netmeteringlimit_kw. There is no need to pass in a NEM value.\n\n\n\n\n\n","category":"method"},{"location":"reopt/inputs/#Financial","page":"REopt Inputs","title":"Financial","text":"","category":"section"},{"location":"reopt/inputs/","page":"REopt Inputs","title":"REopt Inputs","text":"REopt.Financial","category":"page"},{"location":"reopt/inputs/#REopt.Financial","page":"REopt Inputs","title":"REopt.Financial","text":"Financial\n\nFinancial data struct with inner constructor:\n\nfunction Financial(;\n    om_cost_escalation_pct::Float64 = 0.025,\n    elec_cost_escalation_pct::Float64 = 0.019,\n    boiler_fuel_cost_escalation_pct::Float64 = 0.034,\n    chp_fuel_cost_escalation_pct::Float64 = 0.034,\n    offtaker_tax_pct::Float64 = 0.26,\n    offtaker_discount_pct = 0.0564,\n    third_party_ownership::Bool = false,\n    owner_tax_pct::Float64 = 0.26,\n    owner_discount_pct::Float64 = 0.0564,\n    analysis_years::Int = 25,\n    value_of_lost_load_per_kwh::Union{Array{R,1}, R} where R<:Real = 1.00,\n    microgrid_upgrade_cost_pct::Float64 = 0.3,\n    macrs_five_year::Array{Float64,1} = [0.2, 0.32, 0.192, 0.1152, 0.1152, 0.0576],  # IRS pub 946\n    macrs_seven_year::Array{Float64,1} = [0.1429, 0.2449, 0.1749, 0.1249, 0.0893, 0.0892, 0.0893, 0.0446]\n)\n\nnote: Note\nWhen third_party_ownership is false the offtaker's discount and tax percentages are used throughout the model:    if !third_party_ownership\n        owner_tax_pct = offtaker_tax_pct\n        owner_discount_pct = offtaker_discount_pct\n    end\n\n\n\n\n\n","category":"type"},{"location":"reopt/inputs/#ElectricUtility","page":"REopt Inputs","title":"ElectricUtility","text":"","category":"section"},{"location":"reopt/inputs/","page":"REopt Inputs","title":"REopt Inputs","text":"REopt.ElectricUtility","category":"page"},{"location":"reopt/inputs/#REopt.ElectricUtility","page":"REopt Inputs","title":"REopt.ElectricUtility","text":"ElectricUtility\n\nBase.@kwdef struct ElectricUtility\n    outage_start_time_step::Int=0  # for modeling a single outage, with critical load spliced into the baseline load ...\n    outage_end_time_step::Int=0  # ... utiltity production_factor = 0 during the outage\n    allow_simultaneous_export_import::Bool=true  # if true the site has two meters (in effect)\n    # variables below used for minimax the expected outage cost,\n    # with max taken over outage start time, expectation taken over outage duration\n    outage_start_timesteps::Array{Int,1}=Int[]  # we minimize the maximum outage cost over outage start times\n    outage_durations::Array{Int,1}=Int[]  # one-to-one with outage_probabilities, outage_durations can be a random variable\n    outage_probabilities::Array{Real,1}=[1.0]\n    outage_timesteps::Union{Missing, UnitRange} = isempty(outage_durations) ? missing : 1:maximum(outage_durations)\n    scenarios::Union{Missing, UnitRange} = isempty(outage_durations) ? missing : 1:length(outage_durations)\nend\n\n\n\n\n\n","category":"type"},{"location":"reopt/inputs/#PV","page":"REopt Inputs","title":"PV","text":"","category":"section"},{"location":"reopt/inputs/","page":"REopt Inputs","title":"REopt Inputs","text":"REopt.PV","category":"page"},{"location":"reopt/inputs/#REopt.PV","page":"REopt Inputs","title":"REopt.PV","text":"PV\n\nstruct with inner constructor:\n\nfunction PV(;\n    tilt::Real,\n    array_type::Int=1,\n    module_type::Int=0,\n    losses::Real=0.14,\n    azimuth::Real=180,\n    gcr::Real=0.4,\n    radius::Int=0,\n    name::String=\"PV\",\n    location::String=\"both\",\n    existing_kw::Real=0,\n    min_kw::Real=0,\n    max_kw::Real=1.0e9,\n    installed_cost_per_kw::Real=1592.0,\n    om_cost_per_kw::Real=17.0,\n    degradation_pct::Real=0.005,\n    macrs_option_years::Int = 5,\n    macrs_bonus_pct::Float64 = 1.0,\n    macrs_itc_reduction::Float64 = 0.5,\n    kw_per_square_foot::Float64=0.01,\n    acres_per_kw::Float64=6e-3,\n    inv_eff::Float64=0.96,\n    dc_ac_ratio::Float64=1.2,\n    prod_factor_series::Union{Missing, Array{Real,1}} = missing,\n    federal_itc_pct::Float64 = 0.26,\n    federal_rebate_per_kw::Float64 = 0.0,\n    state_ibi_pct::Float64 = 0.0,\n    state_ibi_max::Float64 = 1.0e10,\n    state_rebate_per_kw::Float64 = 0.0,\n    state_rebate_max::Float64 = 1.0e10,\n    utility_ibi_pct::Float64 = 0.0,\n    utility_ibi_max::Float64 = 1.0e10,\n    utility_rebate_per_kw::Float64 = 0.0,\n    utility_rebate_max::Float64 = 1.0e10,\n    production_incentive_per_kwh::Float64 = 0.0,\n    production_incentive_max_benefit::Float64 = 1.0e9,\n    production_incentive_years::Int = 1,\n    production_incentive_max_kw::Float64 = 1.0e9\n    can_net_meter::Bool = true,\n    can_wholesale::Bool = true,\n    can_export_beyond_nem_limit::Bool = true\n)\n\nnote: Note\nIf tilt is not provided then it is set to the Site.latitude. (Which is handled in the Scenario struct.)\n\n\n\n\n\n","category":"type"},{"location":"reopt/inputs/#Wind","page":"REopt Inputs","title":"Wind","text":"","category":"section"},{"location":"reopt/inputs/","page":"REopt Inputs","title":"REopt Inputs","text":"REopt.Wind","category":"page"},{"location":"reopt/inputs/#REopt.Wind","page":"REopt Inputs","title":"REopt.Wind","text":"Wind\n\nstruct with inner constructor:\n\nfunction Wind(;\n    min_kw = 0.0,\n    max_kw = 1.0e9,\n    installed_cost_per_kw = missing,\n    om_cost_per_kw = 35.0,\n    prod_factor_series = missing,\n    size_class = \"\",\n    wind_meters_per_sec = [],\n    wind_direction_degrees = [],\n    temperature_celsius = [],\n    pressure_atmospheres = [],\n    macrs_option_years = 5,\n    macrs_bonus_pct = 0.0,\n    macrs_itc_reduction = 0.5,\n    federal_itc_pct = missing,\n    federal_rebate_per_kw = 0.0,\n    state_ibi_pct = 0.0,\n    state_ibi_max = 1.0e10,\n    state_rebate_per_kw = 0.0,\n    state_rebate_max = 1.0e10,\n    utility_ibi_pct = 0.0,\n    utility_ibi_max = 1.0e10,\n    utility_rebate_per_kw = 0.0,\n    utility_rebate_max = 1.0e10,\n    production_incentive_per_kwh = 0.0,\n    production_incentive_max_benefit = 1.0e9,\n    production_incentive_years = 1,\n    production_incentive_max_kw = 1.0e9,\n    can_net_meter = true,\n    can_wholesale = true,\n    can_export_beyond_nem_limit = true\n)\n\nsize_class must be one of [\"residential\", \"commercial\", \"medium\", \"large\"]. If size_class is not provided then it is determined based on the average electric load.\n\nIf no installed_cost_per_kw is provided then it is determined from:\n\nsize_class_to_installed_cost = Dict(\n    \"residential\"=> 11950.0,\n    \"commercial\"=> 7390.0,\n    \"medium\"=> 4440.0,\n    \"large\"=> 3450.0\n)\n\nThe Federal Investment Tax Credit is adjusted based on the size_class as follows (if the default of 0.3 is not changed):\n\nsize_class_to_itc_incentives = Dict(\n    \"residential\"=> 0.3,\n    \"commercial\"=> 0.3,\n    \"medium\"=> 0.12,\n    \"large\"=> 0.12\n)\n\nIf the prod_factor_series is not provided then NREL's System Advisor Model (SAM) is used to get the wind turbine  production factor.\n\nWind resource values are optional, i.e. (wind_meters_per_sec, wind_direction_degrees, temperature_celsius, and pressure_atmospheres). If not provided then the resource values are downloaded from NREL's Wind Toolkit. These values are passed to SAM to get the turbine production factor.\n\n\n\n\n\n","category":"type"},{"location":"reopt/inputs/#ElectricStorage","page":"REopt Inputs","title":"ElectricStorage","text":"","category":"section"},{"location":"reopt/inputs/","page":"REopt Inputs","title":"REopt Inputs","text":"REopt.ElectricStorageDefaults\nREopt.Degradation","category":"page"},{"location":"reopt/inputs/#REopt.ElectricStorageDefaults","page":"REopt Inputs","title":"REopt.ElectricStorageDefaults","text":"ElectricStorageDefaults\n\nElectric storage system defaults. Overridden by user inputs provided in ElectricStorage.\n\nBase.@kwdef struct ElectricStorageDefaults\n    min_kw::Float64 = 0.0\n    max_kw::Float64 = 1.0e4\n    min_kwh::Float64 = 0.0\n    max_kwh::Float64 = 1.0e6\n    internal_efficiency_pct::Float64 = 0.975\n    inverter_efficiency_pct::Float64 = 0.96\n    rectifier_efficiency_pct::Float64 = 0.96\n    soc_min_pct::Float64 = 0.2\n    soc_init_pct::Float64 = 0.5\n    can_grid_charge::Bool = true\n    installed_cost_per_kw::Float64 = 775.0\n    installed_cost_per_kwh::Float64 = 388.0\n    replace_cost_per_kw::Float64 = 440.0\n    replace_cost_per_kwh::Float64 = 220.0\n    inverter_replacement_year::Int = 10\n    battery_replacement_year::Int = 10\n    macrs_option_years::Int = 7\n    macrs_bonus_pct::Float64 = 1.0\n    macrs_itc_reduction::Float64 = 0.5\n    total_itc_pct::Float64 = 0.0\n    total_rebate_per_kw::Float64 = 0.0\n    total_rebate_per_kwh::Float64 = 0.0\n    charge_efficiency::Float64 = rectifier_efficiency_pct * internal_efficiency_pct^0.5\n    discharge_efficiency::Float64 = inverter_efficiency_pct * internal_efficiency_pct^0.5\n    grid_charge_efficiency::Float64 = can_grid_charge ? charge_efficiency : 0.0\n    model_degradation::Bool = false\n    degradation::Dict = Dict()\n    minimum_avg_soc_fraction::Float64 = 0.0\nend\n\n\n\n\n\n","category":"type"},{"location":"reopt/inputs/#REopt.Degradation","page":"REopt Inputs","title":"REopt.Degradation","text":"Degradation\n\nInputs used when ElectricStorage.model_degradation is true:\n\nBase.@kwdef mutable struct Degradation\n    calendar_fade_coefficient::Float64 = 2.46E-03\n    cycle_fade_coefficient::Float64 = 7.82E-05\n    installed_cost_per_kwh_declination_rate::Float64 = 0.05\n    maintenance_strategy::String = \"augmentation\"  # one of [\"augmentation\", \"replacement\"]\n    maintenance_cost_per_kwh::Vector{<:Real} = Real[]\nend\n\nNone of the above values are required. If ElectricStorage.model_degradation is true then the  defaults above are used. If the maintenance_cost_per_kwh is not provided then it is determined using the ElectricStorage.installed_cost_per_kwh and the installed_cost_per_kwh_declination_rate along with a present worth factor f to account for the present cost of buying a battery in the future. The present worth factor for each day is:\n\nf(day) = frac (1-r_g)^fracday365   (1+r_d)^fracday365 \n\nwhere r_g = installed_cost_per_kwh_declination_rate and r_d = p.s.financial.owner_discount_pct.\n\nNote this day-specific calculation of the present-worth factor accumulates differently from the annually updated discount rate for other net-present value calculations in REopt, and has a higher effective discount rate as a result.  The present  worth factor is used in two different ways, depending on the maintenance_strategy, which is described below.\n\nwarn: Warn\nWhen modeling degradation the following ElectricStorage inputs are not used:replace_cost_per_kw\nreplace_cost_per_kwh\ninverter_replacement_year\nbattery_replacement_yearThe are replaced by the maintenance_cost_per_kwh vector.\n\nnote: Note\nWhen providing the maintenance_cost_per_kwh it must have a length equal to Financial.analysis_years*365.\n\nBattery State Of Health\n\nThe state of health [SOH] is a linear function of the daily average state of charge [Eavg] and the daily equivalent full cycles [EFC]. The initial SOH is set to the optimal battery energy capacity  (in kWh). The evolution of the SOH beyond the first day is:\n\nSOHd = SOHd-1 - hleft(     frac12 k_cal Eavgd-1  sqrtd + k_cyc EFCd-1 quad forall d in 2dots D right)\n\nwhere:\n\nk_cal is the calendar_fade_coefficient\nk_cyc is the cycle_fade_coefficient\nh is the hours per time step\nD is the total number of days, 365 * analysis_years\n\nThe SOH is used to determine the maintence cost of the storage system, which depends on the maintenance_strategy.\n\nAugmentation Maintenance Strategy\n\nThe augmentation maintenance strategy assumes that the battery energy capacity is maintained by replacing degraded cells daily in terms of cost. Using the definition of the SOH above the maintenance cost is:\n\nC_textaug = sum_d in 2dots D 08 C_textinstall f(day) left( SOHd-1 - SOHd right)\n\nwhere\n\nthe 08 factor accounts for sunk costs that do not need to be paid;\nC_textinstall is the ElectricStorage.installed_cost_per_kwh; and\nSOHd-1 - SOHd is the incremental amount of battery capacity lost in a day.\n\nThe C_textaug is added to the objective function to be minimized with all other costs.\n\nReplacement Maintenance Strategy\n\nModeling the replacement maintenance strategy is more complex than the augmentation strategy. Effectively the replacement strategy says that the battery has to be replaced once the SOH hits 80% of the optimal, purchased capacity. It is possible that multiple replacements could be required under this strategy.\n\nwarn: Warn\nThe \"replacement\" maintenance strategy requires integer variables and indicator constraints. Not all solvers support indicator constraints and some solvers are slow with integer variables.\n\nThe replacement strategy cost is:\n\nC_textrepl = B_textkWh N_textrepl f(d_80) C_textinstall\n\nwhere:\n\nB_textkWh is the optimal battery capacity (ElectricStorage.size_kwh in the results dictionary);\nN_textrepl is the number of battery replacments required (a function of the month in which the SOH reaches 80% of original capacity);\nf(d_80) is the present worth factor at approximately the 15th day of the month that the SOH reaches 80% of original capacity.\n\nThe C_textrepl is added to the objective function to be minimized with all other costs.\n\nExample of inputs\n\nThe following shows how one would use the degradation model in REopt via the Scenario inputs:\n\n{\n    ...\n    \"ElectricStorage\": {\n        \"installed_cost_per_kwh\": 390,\n        ...\n        \"model_degradation\": true,\n        \"degradation\": {\n            \"calendar_fade_coefficient\": 2.86E-03,\n            \"cycle_fade_coefficient\": 6.22E-05,\n            \"installed_cost_per_kwh_declination_rate\": 0.06,\n            \"maintenance_strategy\": \"replacement\",\n            ...\n        }\n    },\n    ...\n}\n\nNote that not all of the above inputs are necessary. When not providing calendar_fade_coefficient for example the default value will be used.\n\n\n\n\n\n","category":"type"},{"location":"reopt/inputs/#Generator","page":"REopt Inputs","title":"Generator","text":"","category":"section"},{"location":"reopt/inputs/","page":"REopt Inputs","title":"REopt Inputs","text":"REopt.Generator","category":"page"},{"location":"reopt/inputs/#REopt.Generator","page":"REopt Inputs","title":"REopt.Generator","text":"Generator\n\nstruct with inner constructor:\n\nfunction Generator(;\n    existing_kw::Real=0,\n    min_kw::Real=0,\n    max_kw::Real=1.0e6,\n    installed_cost_per_kw::Real=500.0,\n    om_cost_per_kw::Real=10.0,\n    om_cost_per_kwh::Float64=0.0,\n    fuel_cost_per_gallon::Float64 = 3.0,\n    fuel_slope_gal_per_kwh::Float64 = 0.076,\n    fuel_intercept_gal_per_hr::Float64 = 0.0,\n    fuel_avail_gal::Float64 = 660.0,\n    min_turn_down_pct::Float64 = 0.0,\n    only_runs_during_grid_outage::Bool = true,\n    sells_energy_back_to_grid::Bool = false,\n    can_net_meter::Bool = false,\n    can_wholesale::Bool = false,\n    can_export_beyond_nem_limit = false,\n    macrs_option_years::Int = 0,\n    macrs_bonus_pct::Float64 = 1.0,\n    macrs_itc_reduction::Float64 = 0.0,\n    federal_itc_pct::Float64 = 0.0,\n    federal_rebate_per_kw::Float64 = 0.0,\n    state_ibi_pct::Float64 = 0.0,\n    state_ibi_max::Float64 = 1.0e10,\n    state_rebate_per_kw::Float64 = 0.0,\n    state_rebate_max::Float64 = 1.0e10,\n    utility_ibi_pct::Float64 = 0.0,\n    utility_ibi_max::Float64 = 1.0e10,\n    utility_rebate_per_kw::Float64 = 0.0,\n    utility_rebate_max::Float64 = 1.0e10,\n    production_incentive_per_kwh::Float64 = 0.0,\n    production_incentive_max_benefit::Float64 = 1.0e9,\n    production_incentive_years::Int = 0,\n    production_incentive_max_kw::Float64 = 1.0e9,\n)\n\n\n\n\n\n","category":"type"},{"location":"reopt/inputs/#Settings","page":"REopt Inputs","title":"Settings","text":"","category":"section"},{"location":"reopt/inputs/","page":"REopt Inputs","title":"REopt Inputs","text":"REopt.Settings","category":"page"},{"location":"reopt/inputs/#REopt.Settings","page":"REopt Inputs","title":"REopt.Settings","text":"Settings\n\nData struct for top-level Scenario settings. Captures inputs that do not logically fall under any of the other data structs.\n\nBase.@kwdef struct Settings\n    time_steps_per_hour::Int = 1\n    run_bau::Bool = true\nend\n\n\n\n\n\n","category":"type"},{"location":"reopt/inputs/#ExistingBoiler","page":"REopt Inputs","title":"ExistingBoiler","text":"","category":"section"},{"location":"reopt/inputs/","page":"REopt Inputs","title":"REopt Inputs","text":"REopt.ExistingBoiler","category":"page"},{"location":"reopt/inputs/#REopt.ExistingBoiler","page":"REopt Inputs","title":"REopt.ExistingBoiler","text":"ExistingBoiler\n\nnote: Note\nThe ExistingBoiler default operating cost is zero. Please provide the fuel_cost_per_mmbtu field for the ExistingBoiler if you want non-zero BAU heating costs. The fuel_cost_per_mmbtu can be a scalar, a list of 12 monthly values, or a time series of values for every time step. ExistingBoiler\n\nfunction ExistingBoiler(;\n    max_heat_demand_kw::Real=0,\n    production_type::String = \"hot_water\",\n    chp_prime_mover::String = \"\",\n    max_thermal_factor_on_peak_load::Real = 1.25,\n    efficiency::Real = 0.0,\n    fuel_cost_per_mmbtu::Union{<:Real, AbstractVector{<:Real}} = 0.0,\n    time_steps_per_hour::Int = 1\n)\n\n\n\n\n\n","category":"type"},{"location":"reopt/inputs/#AbsorptionChiller","page":"REopt Inputs","title":"AbsorptionChiller","text":"","category":"section"},{"location":"reopt/inputs/","page":"REopt Inputs","title":"REopt Inputs","text":"REopt.AbsorptionChiller","category":"page"},{"location":"reopt/inputs/#REopt.AbsorptionChiller","page":"REopt Inputs","title":"REopt.AbsorptionChiller","text":"AbsorptionChiller\n\nstruct with inner constructor:\n\nfunction AbsorptionChiller(;\n    min_ton::Real = 0.0,\n    max_ton::Real = 0.0,\n    chiller_cop::Real,\n    chiller_elec_cop::Real = 14.1,\n    installed_cost_per_ton::Real,\n    om_cost_per_ton::Real,\n    macrs_option_years::Real = 0,\n    macrs_bonus_pct::Real = 0\n)\n\n\n\n\n\n","category":"type"},{"location":"reopt/inputs/#CHP","page":"REopt Inputs","title":"CHP","text":"","category":"section"},{"location":"reopt/inputs/","page":"REopt Inputs","title":"REopt Inputs","text":"REopt.CHP","category":"page"},{"location":"reopt/inputs/#REopt.CHP","page":"REopt Inputs","title":"REopt.CHP","text":"CHP\n\nstruct with outer constructor:\n\nprime_mover::String = \"\"\n# following must be provided by user if not providing prime_mover\ninstalled_cost_per_kw::Union{Float64, AbstractVector{Float64}} = NaN\ntech_sizes_for_cost_curve::Union{Float64, AbstractVector{Float64}} = NaN\nom_cost_per_kwh::Float64 = NaN\nelec_effic_half_load = NaN\nelec_effic_full_load::Float64 = NaN\nmin_turn_down_pct::Float64 = NaN\nthermal_effic_full_load::Float64 = NaN\nthermal_effic_half_load::Float64 = NaN\nmin_allowable_kw::Float64 = NaN\nmax_kw::Float64 = NaN\ncooling_thermal_factor::Float64 = NaN  # only needed with cooling load\nunavailability_periods::AbstractVector{Dict} = Dict[]\n\nsize_class::Int = 1\nmin_kw::Float64 = 0.0\nfuel_cost_per_mmbtu::Union{<:Real, AbstractVector{<:Real}} = 0.0,\nom_cost_per_kw::Float64 = 0.0\nom_cost_per_hr_per_kw_rated::Float64 = 0.0\nsupplementary_firing_capital_cost_per_kw::Float64 = 150.0\nsupplementary_firing_max_steam_ratio::Float64 = 1.0\nsupplementary_firing_efficiency::Float64 = 0.92\nstandby_rate_us_dollars_per_kw_per_month = 0.0\nreduces_demand_charges = true\nuse_default_derate::Bool = true\nmax_derate_factor::Float64 = 1.0\nderate_start_temp_degF::Float64 = 0.0\nderate_slope_pct_per_degF::Float64 = 0.0\ncan_supply_steam_turbine::Bool=false\n\nmacrs_option_years::Int = 5\nmacrs_bonus_pct::Float64 = 1.0\nmacrs_itc_reduction::Float64 = 0.5\nfederal_itc_pct::Float64 = 0.1\nfederal_rebate_per_kw::Float64 = 0.0\nstate_ibi_pct::Float64 = 0.0\nstate_ibi_max::Float64 = 1.0e10\nstate_rebate_per_kw::Float64 = 0.0\nstate_rebate_max::Float64 = 1.0e10\nutility_ibi_pct::Float64 = 0.0\nutility_ibi_max::Float64 = 1.0e10\nutility_rebate_per_kw::Float64 = 0.0\nutility_rebate_max::Float64 = 1.0e10\nproduction_incentive_per_kwh::Float64 = 0.0\nproduction_incentive_max_benefit::Float64 = 1.0e9\nproduction_incentive_years::Int = 0\nproduction_incentive_max_kw::Float64 = 1.0e9\ncan_net_meter::Bool = false\ncan_wholesale::Bool = false\ncan_export_beyond_nem_limit::Bool = false\ncan_curtail::Bool = false\n# emissions_factor_lb_CO2_per_mmbtu::Float64\n\n\n\n\n\n","category":"type"},{"location":"reopt/inputs/#HotStorage","page":"REopt Inputs","title":"HotStorage","text":"","category":"section"},{"location":"reopt/inputs/","page":"REopt Inputs","title":"REopt Inputs","text":"REopt.HotThermalStorageDefaults","category":"page"},{"location":"reopt/inputs/#REopt.HotThermalStorageDefaults","page":"REopt Inputs","title":"REopt.HotThermalStorageDefaults","text":"HotThermalStorageDefaults\n\nBase.@kwdef struct HotThermalStorageDefaults <: AbstractThermalStorageDefaults\n    min_gal::Float64 = 0.0\n    max_gal::Float64 = 0.0\n    hot_water_temp_degF::Float64 = 180.0\n    cool_water_temp_degF::Float64 = 160.0\n    internal_efficiency_pct::Float64 = 0.999999\n    soc_min_pct::Float64 = 0.1\n    soc_init_pct::Float64 = 0.5\n    installed_cost_per_gal::Float64 = 1.50\n    thermal_decay_rate_fraction::Float64 = 0.0004\n    om_cost_per_gal::Float64 = 0.0\n    macrs_option_years::Int = 0\n    macrs_bonus_pct::Float64 = 0.0\n    macrs_itc_reduction::Float64 = 0.0\n    total_itc_pct::Float64 = 0.0\n    total_rebate_per_kwh::Float64 = 0.0\nend\n\n\n\n\n\n","category":"type"},{"location":"reopt/inputs/#ColdStorage","page":"REopt Inputs","title":"ColdStorage","text":"","category":"section"},{"location":"reopt/inputs/","page":"REopt Inputs","title":"REopt Inputs","text":"REopt.ColdThermalStorageDefaults","category":"page"},{"location":"reopt/inputs/#REopt.ColdThermalStorageDefaults","page":"REopt Inputs","title":"REopt.ColdThermalStorageDefaults","text":"ColdThermalStorageDefaults\n\nCold thermal energy storage sytem; specifically, a chilled water system used to \nmeet thermal cooling loads.\n\nBase.@kwdef struct ColdThermalStorageDefaults <: AbstractThermalStorageDefaults\n    min_gal::Float64 = 0.0\n    max_gal::Float64 = 0.0\n    hot_water_temp_degF::Float64 = 56.0\n    cool_water_temp_degF::Float64 = 44.0\n    internal_efficiency_pct::Float64 = 0.999999\n    soc_min_pct::Float64 = 0.1\n    soc_init_pct::Float64 = 0.5\n    installed_cost_per_gal::Float64 = 1.50\n    thermal_decay_rate_fraction::Float64 = 0.0004\n    om_cost_per_gal::Float64 = 0.0\n    macrs_option_years::Int = 0\n    macrs_bonus_pct::Float64 = 0.0\n    macrs_itc_reduction::Float64 = 0.0\n    total_itc_pct::Float64 = 0.0\n    total_rebate_per_kwh::Float64 = 0.0\nend\n\n\n\n\n\n","category":"type"},{"location":"reopt/inputs/#DomesticHotWaterLoad","page":"REopt Inputs","title":"DomesticHotWaterLoad","text":"","category":"section"},{"location":"reopt/inputs/","page":"REopt Inputs","title":"REopt Inputs","text":"REopt.DomesticHotWaterLoad","category":"page"},{"location":"reopt/inputs/#REopt.DomesticHotWaterLoad","page":"REopt Inputs","title":"REopt.DomesticHotWaterLoad","text":"DomesticHotWaterLoad\n\nThere are many ways in which a DomesticHotWaterLoad can be defined:\n\nWhen using either doe_reference_name or blended_doe_reference_names in an ElectricLoad one only needs to provide the input key \"DomesticHotWaterLoad\" in the Scenario (JSON or Dict). In this case the values from DoE reference names from the ElectricLoad will be used to define the DomesticHotWaterLoad.\nOne can provide the doe_reference_name or blended_doe_reference_names directly in the DomesticHotWaterLoad key within the Scenario. These values can be combined with the annual_mmbtu or monthly_mmbtu inputs to scale the DoE reference profile(s).\nOne can provide the fuel_loads_mmbtu_per_hour value in the DomesticHotWaterLoad key within the Scenario.\n\nfunction DomesticHotWaterLoad(;\n    doe_reference_name::String = \"\",\n    city::String = \"\",\n    blended_doe_reference_names::Array{String, 1} = String[],\n    blended_doe_reference_percents::Array{<:Real,1} = Real[],\n    annual_mmbtu::Union{Real, Nothing} = nothing,\n    monthly_mmbtu::Array{<:Real,1} = Real[],\n    fuel_loads_mmbtu_per_hour::Array{<:Real,1} = Real[],\n    time_steps_per_hour::Int = 1,\n    latitude::Real=0.0,\n    longitude::Real=0.0\n)\n\n\n\n\n\n","category":"type"},{"location":"reopt/inputs/#SpaceHeatingLoad","page":"REopt Inputs","title":"SpaceHeatingLoad","text":"","category":"section"},{"location":"reopt/inputs/","page":"REopt Inputs","title":"REopt Inputs","text":"REopt.SpaceHeatingLoad","category":"page"},{"location":"reopt/inputs/#REopt.SpaceHeatingLoad","page":"REopt Inputs","title":"REopt.SpaceHeatingLoad","text":"function SpaceHeatingLoad(;\n    doe_reference_name::String = \"\",\n    city::String = \"\",\n    blended_doe_reference_names::Array{String, 1} = String[],\n    blended_doe_reference_percents::Array{<:Real,1} = Real[],\n    annual_mmbtu::Union{Real, Nothing} = nothing,\n    monthly_mmbtu::Array{<:Real,1} = Real[],\n    fuel_loads_mmbtu_per_hour::Array{<:Real,1} = Real[]\n)\n\nThere are many ways to define a SpaceHeatingLoad:\n\na time-series via the fuel_loads_mmbtu_per_hour,\nscaling a DoE Commercial Reference Building (CRB) profile or a blend of CRB profiles to either the annual_mmbtu or monthly_mmbtu values;\nor using the doe_reference_name or blended_doe_reference_names from the ElectricLoad.\n\nWhen using an ElectricLoad defined from a doe_reference_name or blended_doe_reference_names  one only needs to provide an empty Dict in the scenario JSON to add a SpaceHeatingLoad to a  Scenario, i.e.:\n\n...\n\"ElectricLoad\": {\"doe_reference_name\": \"MidriseApartment\"},\n\"SpaceHeatingLoad\" : {},\n...\n\nIn this case the values provided for doe_reference_name, or  blended_doe_reference_names and  blended_doe_reference_percents are copied from the ElectricLoad to the SpaceHeatingLoad.\n\n\n\n\n\n","category":"type"},{"location":"reopt/inputs/#FlexibleHVAC","page":"REopt Inputs","title":"FlexibleHVAC","text":"","category":"section"},{"location":"reopt/inputs/","page":"REopt Inputs","title":"REopt Inputs","text":"REopt.FlexibleHVAC\nREopt.FlexibleHVAC()\nREopt.FlexibleHVAC(::Dict)","category":"page"},{"location":"reopt/inputs/#REopt.FlexibleHVAC","page":"REopt Inputs","title":"REopt.FlexibleHVAC","text":"FlexibleHVAC\n\nEvery model with FlexibleHVAC includes a preprocessing step to calculate the business-as-usual (BAU) cost of meeting the thermal loads using a dead-band controller. The BAU cost is then used in the  binary decision for purchasing the FlexibleHVAC system: if the FlexibleHVAC system is purchased then the heating and cooling costs are determined by the HVAC dispatch that minimizes the lifecycle cost of energy. If the FlexibleHVAC system is not purchased then the BAU heating and cooling costs must be paid.\n\nThere are two construction methods for FlexibleHVAC, which depend on whether or not the data was  loaded in from a JSON file. The issue with data from JSON is that the vector-of-vectors from the JSON  file must be appropriately converted to Julia Matrices. When loading in a Scenario from JSON that  includes a FlexibleHVAC model if you include the flex_hvac_from_json argument to the Scenario  constructor then the conversion to Matrices will be done appropriately. For example:\n\nnote: Note\nAt least one of the inputs for temperature_upper_bound_degC or temperature_lower_bound_degC must be provided to evaluate the FlexibleHVAC option. For example, if only temperature_lower_bound_degC is provided then only a heating system will be evaluated. Also, the heating system will only be used (or purchased) if the exogenous_inputs lead to the temperature at the control_node going below the temperature_lower_bound_degC.\n\nnote: Note\nThe ExistingChiller is electric and so its operating cost is determined by the ElectricTariff.\n\nnote: Note\nThe ExistingBoiler default operating cost is zero. Please provide the fuel_cost_per_mmbtu field for the ExistingBoiler if you want non-zero BAU heating costs. The fuel_cost_per_mmbtu can be a scalar, a list of 12 monthly values, or a time series of values for every time step.\n\n\n\n\n\n","category":"type"},{"location":"reopt/inputs/#REopt.FlexibleHVAC-Tuple{}","page":"REopt Inputs","title":"REopt.FlexibleHVAC","text":"function FlexibleHVAC(;\n    system_matrix::AbstractMatrix,\n    input_matrix::AbstractMatrix,\n    exogenous_inputs::AbstractMatrix,\n    control_node::Int64,\n    initial_temperatures::AbstractVector,\n    temperature_upper_bound_degC::Union{Real, Nothing} = nothing,\n    temperature_lower_bound_degC::Union{Real, Nothing} = nothing,\n    installed_cost::Float64\n)\n\nWhen the A, B, and u values are in Matrix format (note u is normally a vector but in our case it has a time index in the second dimension)\n\n\n\n\n\n","category":"method"},{"location":"reopt/inputs/#REopt.FlexibleHVAC-Tuple{Dict}","page":"REopt Inputs","title":"REopt.FlexibleHVAC","text":"FlexibleHVAC(dict_from_json::Dict)\n\n\n\n\n\n","category":"method"},{"location":"#REopt.jl","page":"Home","title":"REopt.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Renewable Energy Optimization and Integration","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nThis package is currently under development and not necessarily stable. It contains a subset of the REopt API capabilities.","category":"page"},{"location":"#Installing","page":"Home","title":"Installing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"REopt\")","category":"page"},{"location":"developer/concept/#Design-Concepts-for-the-REopt-Module","page":"Design Concepts for the REopt Module","title":"Design Concepts for the REopt Module","text":"","category":"section"},{"location":"developer/concept/","page":"Design Concepts for the REopt Module","title":"Design Concepts for the REopt Module","text":"At a high level each REopt model consists of four major components:","category":"page"},{"location":"developer/concept/","page":"Design Concepts for the REopt Module","title":"Design Concepts for the REopt Module","text":"The Scenario as defined by the user's inputs and default values.\nThe REoptInputs, which convert the Scenario into the necessary values for the REopt mathematical program.\nThe REopt Model (built here), which includes all the constraints and the objective function that are built using the REoptInputs\nAnd the results, which are returned to the user and derived from the optimal solution of the REopt Model.","category":"page"},{"location":"developer/concept/","page":"Design Concepts for the REopt Module","title":"Design Concepts for the REopt Module","text":"The REopt Model is built via the build_reopt! method. However, the run_reopt method includes build_reopt! within it so typically a user does not need to directly call build_reopt! (unless they wish to modify the model before solving it, eg. by adding a constraint).","category":"page"},{"location":"developer/concept/","page":"Design Concepts for the REopt Module","title":"Design Concepts for the REopt Module","text":"run_reopt is the main interface for users.","category":"page"},{"location":"developer/concept/#Technology-size-constraints","page":"Design Concepts for the REopt Module","title":"Technology size constraints","text":"","category":"section"},{"location":"developer/concept/#Upper-size-limits","page":"Design Concepts for the REopt Module","title":"Upper size limits","text":"","category":"section"},{"location":"developer/concept/","page":"Design Concepts for the REopt Module","title":"Design Concepts for the REopt Module","text":"The max_kw input value for any technology is considered to be the maximum additional capacity that may be installed beyond the existing_kw. Note also that the Site space constraints (roof_squarefeet and land_acres) for PV technologies can be less than the provided max_kw value.","category":"page"},{"location":"developer/concept/#Lower-size-limits","page":"Design Concepts for the REopt Module","title":"Lower size limits","text":"","category":"section"},{"location":"developer/concept/","page":"Design Concepts for the REopt Module","title":"Design Concepts for the REopt Module","text":"The min_kw input value for any technology sets the lower bound on the capacity. If min_kw is non-zero then the model will be forced to choose at least that system size. The min_kw value is set equal to the existing_kw value in the Business As Usual scenario.","category":"page"},{"location":"developer/concept/#Business-As-Usual-Scenario","page":"Design Concepts for the REopt Module","title":"Business As Usual Scenario","text":"","category":"section"},{"location":"developer/concept/","page":"Design Concepts for the REopt Module","title":"Design Concepts for the REopt Module","text":"In order to calculate the Net Present Value of the optimal solution, as well as other baseline metrics, one can optionally run the Business As Usual (BAU) scenario. The option for running the BAU scenario in addition to the optimal scenario is in the Settings. The default value for Settings.run_bau is true so that when an array of JuMP.Models is provided to run_reopt the BAU scenario is also run. For example:","category":"page"},{"location":"developer/concept/","page":"Design Concepts for the REopt Module","title":"Design Concepts for the REopt Module","text":"m1 = Model(optimizer_with_attributes(Xpress.Optimizer, \"OUTPUTLOG\" => 0))\nm2 = Model(optimizer_with_attributes(Xpress.Optimizer, \"OUTPUTLOG\" => 0))\nresults = run_reopt([m1,m2], \"./scenarios/pv_storage.json\")","category":"page"},{"location":"developer/concept/","page":"Design Concepts for the REopt Module","title":"Design Concepts for the REopt Module","text":"The BAU scenario is created by modifying the REoptInputs (created from the user's Scenario). In the BAU scenario we have the following assumptions:","category":"page"},{"location":"developer/concept/","page":"Design Concepts for the REopt Module","title":"Design Concepts for the REopt Module","text":"Each existing technology has zero capital cost, but does have operations and maintenance costs.\nThe ElectricTariff, Financial, Site, ElectricLoad, and ElectricUtility inputs are the same as the optimal case.\nThe min_kw and max_kw values are set to the existing_kw value.","category":"page"}]
}
